# DX Seed プラットフォーム システム設計書

## **目次**

1. [システム概要・アーキテクチャ](#1-システム概要アーキテクチャ)
2. [データベース設計](#2-データベース設計)
3. [API設計](#3-api設計)
4. [フロントエンド設計](#4-フロントエンド設計)
5. [バックエンド設計](#5-バックエンド設計)
6. [AI・機械学習システム設計](#6-ai機械学習システム設計)
7. [セキュリティ設計](#7-セキュリティ設計)
8. [インフラ・デプロイ設計](#8-インフラデプロイ設計)
9. [外部システム連携設計](#9-外部システム連携設計)
10. [監視・運用設計](#10-監視運用設計)

---

## **1. システム概要・アーキテクチャ**

### **1.1 システム全体構成図**

```mermaid
graph TB
    %% フロントエンド層
    subgraph "Frontend Layer"
        WebApp[Web Application<br/>React + TypeScript]
        MobileApp[Mobile App<br/>PWA]
        AdminPanel[Admin Panel<br/>管理者画面]
    end

    %% API Gateway層
    subgraph "API Gateway Layer"
        Gateway[API Gateway<br/>Kong/AWS API Gateway]
        LoadBalancer[Load Balancer<br/>AWS ALB]
    end

    %% マイクロサービス層
    subgraph "Microservices Layer"
        AuthService[認証サービス<br/>Auth Service]
        UserService[ユーザー管理<br/>User Service]
        LMSService[学習管理<br/>LMS Service]
        MatchingService[マッチング<br/>Matching Service]
        ProjectService[案件管理<br/>Project Service]
        PaymentService[報酬管理<br/>Payment Service]
        EmploymentService[雇用管理<br/>Employment Service]
        SupportService[生活支援<br/>Support Service]
        AnalyticsService[分析<br/>Analytics Service]
        TranslationService[翻訳<br/>Translation Service]
    end

    %% データ層
    subgraph "Data Layer"
        PostgresMain[(PostgreSQL<br/>メインDB)]
        Redis[(Redis<br/>キャッシュ)]
        MongoDB[(MongoDB<br/>ログ・分析)]
        S3[(AWS S3<br/>ファイル保存)]
        ElasticSearch[(Elasticsearch<br/>検索エンジン)]
    end

    %% 外部サービス
    subgraph "External Services"
        PaymentGW[決済ゲートウェイ<br/>Stripe/PayPal]
        VideoService[動画配信<br/>AWS MediaServices]
        AIService[AI サービス<br/>OpenAI/AWS SageMaker]
        TranslateAPI[翻訳API<br/>Google Translate]
        ZoomAPI[Zoom API<br/>面談システム]
    end

    %% 接続関係
    WebApp --> Gateway
    MobileApp --> Gateway
    AdminPanel --> Gateway
    
    Gateway --> LoadBalancer
    LoadBalancer --> AuthService
    LoadBalancer --> UserService
    LoadBalancer --> LMSService
    LoadBalancer --> MatchingService
    LoadBalancer --> ProjectService
    LoadBalancer --> PaymentService
    LoadBalancer --> EmploymentService
    LoadBalancer --> SupportService
    LoadBalancer --> AnalyticsService
    LoadBalancer --> TranslationService

    AuthService --> PostgresMain
    UserService --> PostgresMain
    LMSService --> PostgresMain
    MatchingService --> PostgresMain
    ProjectService --> PostgresMain
    PaymentService --> PostgresMain
    EmploymentService --> PostgresMain
    SupportService --> PostgresMain
    
    AnalyticsService --> MongoDB
    TranslationService --> Redis
    
    LMSService --> S3
    EmploymentService --> S3
    
    MatchingService --> ElasticSearch
    LMSService --> ElasticSearch

    PaymentService --> PaymentGW
    LMSService --> VideoService
    SupportService --> AIService
    TranslationService --> TranslateAPI
    SupportService --> ZoomAPI
```

### **1.2 マイクロサービス詳細構成**

#### **1.2.1 認証サービス（Auth Service）**
**目的：** 全ユーザーの認証・認可を統一管理

**主要機能：**
- ユーザー認証（ログイン・ログアウト）
- JWT トークン発行・検証
- 多要素認証（MFA）
- 外部OAuth連携（Google、Microsoft等）
- 権限管理（RBAC：Role-Based Access Control）

**技術スタック：**
- **言語：** Node.js + TypeScript
- **フレームワーク：** Express.js
- **認証ライブラリ：** Passport.js、jsonwebtoken
- **データベース：** PostgreSQL
- **キャッシュ：** Redis

**ポート：** 3001

#### **1.2.2 ユーザー管理サービス（User Service）**
**目的：** ユーザー情報・プロフィール・組織管理

**主要機能：**
- ユーザープロフィール管理
- 組織・企業情報管理
- 権限・役割管理
- 個人設定・通知設定

**技術スタック：**
- **言語：** Node.js + TypeScript
- **フレームワーク：** Fastify
- **ORM：** Prisma
- **データベース：** PostgreSQL

**ポート：** 3002

#### **1.2.3 学習管理サービス（LMS Service）**
**目的：** 学習コンテンツ・進捗・評価管理

**主要機能：**
- コンテンツ管理（動画・テスト・教材）
- 学習進捗追跡
- 評価・テスト機能
- 証明書発行

**技術スタック：**
- **言語：** Node.js + TypeScript
- **フレームワーク：** NestJS
- **データベース：** PostgreSQL
- **ファイル保存：** AWS S3
- **動画処理：** AWS MediaConvert

**ポート：** 3003

#### **1.2.4 マッチングサービス（Matching Service）**
**目的：** 人材と企業のマッチング処理

**主要機能：**
- 人材・企業データ管理
- マッチングアルゴリズム
- 検索・フィルタリング
- 面接調整・仲介

**技術スタック：**
- **言語：** Python + FastAPI
- **機械学習：** scikit-learn、pandas
- **検索エンジン：** Elasticsearch
- **データベース：** PostgreSQL

**ポート：** 3004

#### **1.2.5 案件管理サービス（Project Service）**
**目的：** プロジェクト・タスク・進捗管理

**主要機能：**
- 案件登録・管理
- チーム編成
- 進捗管理
- 品質管理

**技術スタック：**
- **言語：** Node.js + TypeScript
- **フレームワーク：** Express.js
- **データベース：** PostgreSQL
- **ファイル管理：** AWS S3

**ポート：** 3005

#### **1.2.6 報酬管理サービス（Payment Service）**
**目的：** 報酬計算・支払い処理

**主要機能：**
- 報酬計算
- 支払い処理
- 税務処理
- 履歴管理

**技術スタック：**
- **言語：** Node.js + TypeScript
- **フレームワーク：** Express.js
- **決済API：** Stripe、PayPal
- **データベース：** PostgreSQL

**ポート：** 3006

#### **1.2.7 雇用管理サービス（Employment Service）**
**目的：** 海外人材の雇用手続き・管理

**主要機能：**
- 雇用契約書作成
- 在留資格手続き支援
- 法的要件管理
- 継続的サポート記録

**技術スタック：**
- **言語：** Node.js + TypeScript
- **フレームワーク：** NestJS
- **PDF生成：** Puppeteer
- **データベース：** PostgreSQL

**ポート：** 3007

#### **1.2.8 生活支援サービス（Support Service）**
**目的：** 海外人材の生活支援・相談対応

**主要機能：**
- AI チャットボット
- レコメンド機能
- 面談予約・管理
- 相談記録管理

**技術スタック：**
- **言語：** Python + FastAPI
- **AI：** OpenAI API、Langchain
- **データベース：** PostgreSQL + MongoDB
- **リアルタイム通信：** WebSocket

**ポート：** 3008

#### **1.2.9 分析サービス（Analytics Service）**
**目的：** データ分析・レポート生成

**主要機能：**
- 学習データ分析
- マッチング効果分析
- 予測分析
- レポート生成

**技術スタック：**
- **言語：** Python + FastAPI
- **分析ライブラリ：** pandas、numpy、scikit-learn
- **可視化：** Plotly、Matplotlib
- **データベース：** MongoDB、PostgreSQL

**ポート：** 3009

#### **1.2.10 翻訳サービス（Translation Service）**
**目的：** 多言語翻訳・言語処理

**主要機能：**
- リアルタイム翻訳
- コンテンツ翻訳
- 言語検出
- 翻訳品質管理

**技術スタック：**
- **言語：** Node.js + TypeScript
- **翻訳API：** Google Translate、DeepL
- **キャッシュ：** Redis
- **データベース：** PostgreSQL

**ポート：** 3010

### **1.3 通信プロトコル**

#### **1.3.1 同期通信**
- **REST API：** HTTP/HTTPS による標準的なAPI通信
- **GraphQL：** 複雑なデータ取得・更新処理用
- **gRPC：** サービス間の高速通信用

#### **1.3.2 非同期通信**
- **Message Queue：** AWS SQS を使用したメッセージング
- **Event Streaming：** Apache Kafka によるイベント配信
- **WebSocket：** リアルタイム通信（チャット・通知）

### **1.4 データフロー図**

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Frontend as フロントエンド
    participant Gateway as APIゲートウェイ
    participant Auth as 認証サービス
    participant LMS as LMSサービス
    participant DB as データベース
    participant S3 as ファイルストレージ

    User->>Frontend: ログイン要求
    Frontend->>Gateway: 認証API呼び出し
    Gateway->>Auth: 認証処理
    Auth->>DB: ユーザー情報確認
    DB-->>Auth: ユーザー情報返却
    Auth-->>Gateway: JWTトークン発行
    Gateway-->>Frontend: 認証結果返却
    Frontend-->>User: ログイン完了

    User->>Frontend: 動画視聴要求
    Frontend->>Gateway: 学習コンテンツAPI呼び出し
    Gateway->>Auth: トークン検証
    Auth-->>Gateway: 検証結果
    Gateway->>LMS: コンテンツ取得
    LMS->>DB: コンテンツ情報取得
    DB-->>LMS: コンテンツ情報返却
    LMS->>S3: 動画ファイル取得
    S3-->>LMS: 動画URL返却
    LMS-->>Gateway: コンテンツ情報返却
    Gateway-->>Frontend: 動画情報返却
    Frontend-->>User: 動画再生
```

---

## **2. データベース設計**

### **2.1 データベース構成概要**

**主要データベース：**
- **PostgreSQL：** メインデータベース（ACID準拠の重要データ）
- **Redis：** キャッシュ・セッション管理
- **MongoDB：** ログ・分析データ・非構造化データ
- **Elasticsearch：** 検索・フィルタリング用

### **2.2 PostgreSQL データベース設計**

#### **2.2.1 ユーザー・認証関連テーブル**

```sql
-- ユーザーマスタテーブル
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255),
    user_type VARCHAR(50) NOT NULL, -- 'dx_talent', 'foreign_talent', 'company_admin', 'company_employee', 'support_staff', 'admin'
    status VARCHAR(20) DEFAULT 'active', -- 'active', 'inactive', 'suspended'
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP
);

-- ユーザープロフィールテーブル
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    first_name_kana VARCHAR(100),
    last_name_kana VARCHAR(100),
    birth_date DATE,
    gender VARCHAR(10), -- 'male', 'female', 'other'
    nationality VARCHAR(3), -- ISO 3166-1 alpha-3
    phone VARCHAR(20),
    address JSONB, -- 住所情報（構造化）
    profile_image_url VARCHAR(500),
    languages JSONB, -- 対応言語・レベル
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 企業情報テーブル
CREATE TABLE companies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    name_kana VARCHAR(255),
    industry VARCHAR(100),
    employee_count INTEGER,
    address JSONB,
    phone VARCHAR(20),
    email VARCHAR(255),
    website VARCHAR(500),
    description TEXT,
    is_specific_skill_certified BOOLEAN DEFAULT false, -- 特定技能受け入れ認定
    certification_number VARCHAR(100), -- 認定番号
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 企業-ユーザー関連テーブル
CREATE TABLE company_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL, -- 'admin', 'hr_manager', 'employee', 'support_staff'
    department VARCHAR(100),
    position VARCHAR(100),
    permissions JSONB, -- 権限設定
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(company_id, user_id)
);

-- 権限管理テーブル
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    permissions JSONB, -- 権限のJSONリスト
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by UUID REFERENCES users(id),
    UNIQUE(user_id, role_id)
);
```

#### **2.2.2 LMS関連テーブル**

```sql
-- コンテンツカテゴリテーブル
CREATE TABLE content_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    name_translations JSONB, -- 多言語対応
    description TEXT,
    parent_id UUID REFERENCES content_categories(id),
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 学習コンテンツテーブル
CREATE TABLE learning_contents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    title_translations JSONB, -- 多言語タイトル
    description TEXT,
    description_translations JSONB,
    category_id UUID REFERENCES content_categories(id),
    content_type VARCHAR(50), -- 'video', 'text', 'quiz', 'interactive'
    difficulty_level VARCHAR(20), -- 'beginner', 'intermediate', 'advanced'
    estimated_duration INTEGER, -- 推定学習時間（分）
    prerequisites JSONB, -- 前提条件のコンテンツID配列
    content_data JSONB, -- コンテンツ固有データ
    file_url VARCHAR(500), -- ファイルのURL
    thumbnail_url VARCHAR(500),
    is_published BOOLEAN DEFAULT false,
    published_at TIMESTAMP,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 学習進捗テーブル
CREATE TABLE learning_progress (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    content_id UUID REFERENCES learning_contents(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'not_started', -- 'not_started', 'in_progress', 'completed', 'skipped'
    progress_percentage DECIMAL(5,2) DEFAULT 0.00,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    last_accessed_at TIMESTAMP,
    time_spent INTEGER DEFAULT 0, -- 学習時間（秒）
    attempts INTEGER DEFAULT 0, -- 試行回数
    best_score DECIMAL(5,2), -- 最高スコア
    notes TEXT, -- ユーザーメモ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, content_id)
);

-- クイズ・テストテーブル
CREATE TABLE quizzes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_id UUID REFERENCES learning_contents(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    title_translations JSONB,
    instructions TEXT,
    instructions_translations JSONB,
    time_limit INTEGER, -- 制限時間（秒）
    passing_score DECIMAL(5,2) DEFAULT 70.00,
    max_attempts INTEGER DEFAULT 3,
    shuffle_questions BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 問題テーブル
CREATE TABLE quiz_questions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    quiz_id UUID REFERENCES quizzes(id) ON DELETE CASCADE,
    question_text TEXT NOT NULL,
    question_text_translations JSONB,
    question_type VARCHAR(20), -- 'multiple_choice', 'single_choice', 'text', 'file_upload'
    options JSONB, -- 選択肢
    correct_answers JSONB, -- 正解
    explanation TEXT, -- 解説
    explanation_translations JSONB,
    points DECIMAL(5,2) DEFAULT 1.00,
    sort_order INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- テスト結果テーブル
CREATE TABLE quiz_attempts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    quiz_id UUID REFERENCES quizzes(id) ON DELETE CASCADE,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    score DECIMAL(5,2),
    passed BOOLEAN,
    time_taken INTEGER, -- 所要時間（秒）
    answers JSONB, -- 回答内容
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 証明書テーブル
CREATE TABLE certificates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    content_id UUID REFERENCES learning_contents(id),
    certificate_type VARCHAR(50), -- 'completion', 'achievement', 'skill_certification'
    title VARCHAR(255) NOT NULL,
    description TEXT,
    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    certificate_url VARCHAR(500), -- PDFファイルのURL
    verification_code VARCHAR(100) UNIQUE,
    metadata JSONB, -- 追加情報
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### **2.2.3 マッチング関連テーブル**

```sql
-- DX人材スキルテーブル
CREATE TABLE dx_talent_skills (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    skill_category VARCHAR(100), -- 'programming', 'data_analysis', 'ai_ml', 'business_efficiency'
    skill_name VARCHAR(100),
    proficiency_level VARCHAR(20), -- 'beginner', 'intermediate', 'advanced', 'expert'
    years_of_experience DECIMAL(3,1),
    verified BOOLEAN DEFAULT false, -- スキル認証済み
    verified_at TIMESTAMP,
    verified_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 海外人材履歴書テーブル
CREATE TABLE foreign_talent_resumes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    
    -- 基本情報
    native_name VARCHAR(255), -- 母国語名
    romaji_name VARCHAR(255), -- ローマ字名
    katakana_name VARCHAR(255), -- カタカナ名
    birth_place VARCHAR(255), -- 出生地
    
    -- パスポート情報
    passport_number VARCHAR(50),
    passport_issued_date DATE,
    passport_expiry_date DATE,
    passport_issuing_country VARCHAR(3),
    
    -- 在留資格情報
    current_visa_status VARCHAR(100),
    visa_expiry_date DATE,
    entry_history JSONB, -- 出入国歴
    
    -- 身体・健康情報
    height INTEGER, -- cm
    weight INTEGER, -- kg
    blood_type VARCHAR(5),
    dominant_hand VARCHAR(10), -- 'right', 'left'
    vision_left DECIMAL(3,1),
    vision_right DECIMAL(3,1),
    color_vision_normal BOOLEAN,
    health_status VARCHAR(20), -- 'excellent', 'good', 'fair', 'poor'
    medical_conditions TEXT,
    medications TEXT,
    allergies TEXT,
    
    -- 生活習慣
    smoking VARCHAR(20), -- 'never', 'former', 'current'
    drinking VARCHAR(20), -- 'never', 'occasionally', 'regularly'
    has_tattoos BOOLEAN,
    tattoo_details TEXT,
    religion VARCHAR(100),
    dietary_restrictions TEXT,
    
    -- 家族情報
    marital_status VARCHAR(20), -- 'single', 'married', 'divorced', 'widowed'
    spouse_info JSONB, -- 配偶者情報
    children_info JSONB, -- 子供情報
    family_members JSONB, -- 家族構成
    dependents JSONB, -- 扶養家族
    japan_accompaniment JSONB, -- 日本同伴予定
    
    -- 特定技能関連
    desired_skill_fields JSONB, -- 希望分野配列
    skill_test_results JSONB, -- 技能試験結果
    japanese_test_results JSONB, -- 日本語試験結果
    work_preferences JSONB, -- 就労希望条件
    
    -- 志望動機・自己PR
    motivation_for_japan TEXT, -- 日本就労動機
    field_selection_reason TEXT, -- 分野選択理由
    experience_summary TEXT, -- 経験・実績
    strengths TEXT, -- 長所
    weaknesses TEXT, -- 短所
    hobbies TEXT, -- 趣味
    self_introduction TEXT, -- 自己PR
    
    -- 完成度・確認
    completion_percentage DECIMAL(5,2) DEFAULT 0.00,
    is_complete BOOLEAN DEFAULT false,
    completed_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 学歴テーブル
CREATE TABLE education_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    institution_name VARCHAR(255) NOT NULL,
    institution_location VARCHAR(255),
    degree_type VARCHAR(100), -- 'elementary', 'junior_high', 'high_school', 'vocational', 'bachelor', 'master', 'doctorate'
    field_of_study VARCHAR(255),
    start_date DATE,
    end_date DATE,
    graduation_status VARCHAR(20), -- 'graduated', 'current', 'dropped_out'
    gpa DECIMAL(4,2),
    achievements TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 職歴テーブル
CREATE TABLE work_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    company_location VARCHAR(255),
    department VARCHAR(255),
    position VARCHAR(255),
    job_description TEXT,
    start_date DATE,
    end_date DATE,
    is_current BOOLEAN DEFAULT false,
    leaving_reason TEXT,
    annual_salary DECIMAL(12,2),
    salary_currency VARCHAR(3),
    skills_used JSONB, -- 使用技術・スキル
    achievements TEXT, -- 実績・成果
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 資格・免許テーブル
CREATE TABLE qualifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    qualification_type VARCHAR(100), -- 'japanese_language', 'skill_test', 'professional', 'other'
    qualification_name VARCHAR(255) NOT NULL,
    issuing_organization VARCHAR(255),
    obtained_date DATE,
    expiry_date DATE,
    score VARCHAR(100), -- スコア・級
    certificate_number VARCHAR(100),
    verification_url VARCHAR(500),
    certificate_file_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 企業求人情報テーブル
CREATE TABLE job_postings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    requirements JSONB, -- 必要スキル・経験
    preferred_qualifications JSONB, -- 歓迎条件
    job_type VARCHAR(50), -- 'full_time', 'part_time', 'contract', 'internship'
    work_location VARCHAR(255),
    salary_min DECIMAL(12,2),
    salary_max DECIMAL(12,2),
    salary_currency VARCHAR(3) DEFAULT 'JPY',
    benefits TEXT,
    specific_skill_field VARCHAR(100), -- 特定技能分野
    japanese_level_required VARCHAR(10), -- 必要日本語レベル
    visa_sponsorship BOOLEAN DEFAULT false,
    application_deadline DATE,
    start_date DATE,
    is_active BOOLEAN DEFAULT true,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- マッチングテーブル
CREATE TABLE matching_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    talent_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
    job_posting_id UUID REFERENCES job_postings(id),
    matching_type VARCHAR(50), -- 'dx_talent', 'foreign_talent'
    matching_score DECIMAL(5,2), -- AIマッチングスコア
    status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'company_interested', 'interview_scheduled', 'interviewed', 'hired', 'rejected'
    company_interest_date TIMESTAMP,
    interview_scheduled_date TIMESTAMP,
    interview_completed_date TIMESTAMP,
    decision_date TIMESTAMP,
    rejection_reason TEXT,
    notes TEXT,
    created_by UUID REFERENCES users(id), -- マッチング作成者
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 面談記録テーブル
CREATE TABLE interview_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    matching_id UUID REFERENCES matching_records(id) ON DELETE CASCADE,
    interview_type VARCHAR(50), -- 'initial', 'technical', 'final', 'online', 'in_person'
    scheduled_at TIMESTAMP,
    actual_start_time TIMESTAMP,
    actual_end_time TIMESTAMP,
    interviewer_notes TEXT,
    talent_feedback TEXT,
    company_feedback TEXT,
    evaluation_score DECIMAL(3,1), -- 1-10点評価
    decision VARCHAR(50), -- 'proceed', 'reject', 'on_hold'
    next_steps TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### **2.2.4 雇用管理関連テーブル**

```sql
-- 雇用契約テーブル
CREATE TABLE employment_contracts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE,
    employee_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    matching_id UUID REFERENCES matching_records(id),
    
    -- 契約基本情報
    contract_type VARCHAR(50), -- 'specific_skill_1', 'specific_skill_2', 'permanent', 'contract'
    contract_number VARCHAR(100) UNIQUE,
    start_date DATE NOT NULL,
    end_date DATE,
    probation_period INTEGER, -- 試用期間（月）
    
    -- 職務情報
    job_title VARCHAR(255),
    department VARCHAR(255),
    work_location VARCHAR(500),
    job_description TEXT,
    specific_skill_field VARCHAR(100), -- 特定技能分野
    
    -- 労働条件
    working_hours_per_week DECIMAL(4,1),
    working_days_per_week INTEGER,
    overtime_allowed BOOLEAN DEFAULT false,
    shift_work BOOLEAN DEFAULT false,
    night_shift_allowed BOOLEAN DEFAULT false,
    
    -- 給与・報酬
    base_salary DECIMAL(12,2),
    salary_type VARCHAR(20), -- 'monthly', 'hourly', 'annual'
    overtime_rate DECIMAL(5,2), -- 残業代率
    allowances JSONB, -- 各種手当
    bonus_structure TEXT,
    
    -- 休暇・福利厚生
    annual_leave_days INTEGER,
    sick_leave_days INTEGER,
    other_benefits TEXT,
    social_insurance JSONB, -- 社会保険
    
    -- 契約状況
    status VARCHAR(50) DEFAULT 'draft', -- 'draft', 'pending_approval', 'active', 'terminated', 'expired'
    signed_by_employee_at TIMESTAMP,
    signed_by_company_at TIMESTAMP,
    approved_by UUID REFERENCES users(id),
    approved_at TIMESTAMP,
    
    -- 書類関連
    contract_file_url VARCHAR(500), -- 契約書PDFのURL
    digital_signature_employee TEXT, -- 従業員のデジタル署名
    digital_signature_company TEXT, -- 企業のデジタル署名
    
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 在留資格管理テーブル
CREATE TABLE visa_management (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    employee_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    contract_id UUID REFERENCES employment_contracts(id),
    
    -- 現在の在留資格
    current_visa_type VARCHAR(100), -- 在留資格の種類
    current_visa_expiry DATE,
    current_activity_description TEXT,
    
    -- 申請情報
    application_type VARCHAR(50), -- 'change', 'renewal', 'extension'
    application_date DATE,
    application_number VARCHAR(100),
    applied_visa_type VARCHAR(100),
    applied_activity_description TEXT,
    application_reason TEXT,
    
    -- 必要書類
    required_documents JSONB, -- 必要書類リスト
    submitted_documents JSONB, -- 提出済み書類
    document_status VARCHAR(50), -- 'incomplete', 'complete', 'under_review'
    
    -- 審査状況
    review_status VARCHAR(50), -- 'pending', 'under_review', 'approved', 'rejected', 'supplementary_required'
    result_notification_date DATE,
    new_visa_expiry DATE,
    rejection_reason TEXT,
    supplementary_requirements TEXT,
    
    -- 手続きサポート
    support_agent_id UUID REFERENCES users(id), -- 担当サポートスタッフ
    administrative_scrivener_id UUID, -- 行政書士ID（外部）
    application_fee DECIMAL(10,2),
    fee_paid_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 支援計画テーブル
CREATE TABLE support_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    employee_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    contract_id UUID REFERENCES employment_contracts(id),
    
    -- 支援計画基本情報
    plan_type VARCHAR(50), -- 'direct', 'registered_support_organization'
    registered_support_org_id UUID, -- 登録支援機関ID（外部）
    plan_start_date DATE,
    plan_end_date DATE,
    
    -- 法定支援項目
    orientation_completed BOOLEAN DEFAULT false,
    orientation_date DATE,
    
    housing_support_provided BOOLEAN DEFAULT false,
    housing_support_details TEXT,
    
    life_guidance_provided BOOLEAN DEFAULT false,
    life_guidance_frequency VARCHAR(50), -- 'weekly', 'monthly', 'as_needed'
    
    japanese_learning_support BOOLEAN DEFAULT false,
    japanese_learning_details TEXT,
    
    complaint_consultation_available BOOLEAN DEFAULT false,
    consultation_contact_info TEXT,
    
    japanese_contact_support BOOLEAN DEFAULT false,
    contact_support_details TEXT,
    
    non_japanese_contact_support BOOLEAN DEFAULT false,
    non_japanese_support_language VARCHAR(50),
    
    notification_support BOOLEAN DEFAULT false,
    
    career_consultation_available BOOLEAN DEFAULT false,
    
    voluntary_departure_support BOOLEAN DEFAULT false,
    
    -- 実施記録
    support_implementation_records JSONB, -- 支援実施記録
    
    -- 報告書
    quarterly_reports JSONB, -- 四半期報告書
    annual_report TEXT, -- 年次報告書
    
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 労働管理テーブル
CREATE TABLE work_management (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    employee_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    contract_id UUID REFERENCES employment_contracts(id),
    
    -- 勤務時間管理
    work_date DATE NOT NULL,
    start_time TIME,
    end_time TIME,
    break_time_minutes INTEGER DEFAULT 0,
    overtime_minutes INTEGER DEFAULT 0,
    work_type VARCHAR(50), -- 'regular', 'overtime', 'holiday', 'sick_leave', 'annual_leave'
    
    -- 評価
    daily_performance_score DECIMAL(3,1), -- 日次パフォーマンス（1-10）
    supervisor_comments TEXT,
    employee_notes TEXT,
    
    -- 出勤状況
    attendance_status VARCHAR(50), -- 'present', 'absent', 'late', 'early_leave'
    late_minutes INTEGER DEFAULT 0,
    early_leave_minutes INTEGER DEFAULT 0,
    absence_reason TEXT,
    
    -- 承認
    approved_by UUID REFERENCES users(id),
    approved_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(employee_user_id, work_date)
);

-- 給与管理テーブル
CREATE TABLE payroll_management (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    employee_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    contract_id UUID REFERENCES employment_contracts(id),
    
    -- 給与期間
    pay_period_start DATE NOT NULL,
    pay_period_end DATE NOT NULL,
    pay_date DATE,
    
    -- 基本給与
    base_salary DECIMAL(12,2),
    regular_hours DECIMAL(6,2),
    regular_pay DECIMAL(12,2),
    
    -- 残業・手当
    overtime_hours DECIMAL(6,2) DEFAULT 0,
    overtime_pay DECIMAL(12,2) DEFAULT 0,
    holiday_hours DECIMAL(6,2) DEFAULT 0,
    holiday_pay DECIMAL(12,2) DEFAULT 0,
    allowances JSONB, -- 各種手当の詳細
    
    -- 総支給額
    gross_pay DECIMAL(12,2),
    
    -- 控除
    income_tax DECIMAL(12,2) DEFAULT 0,
    resident_tax DECIMAL(12,2) DEFAULT 0,
    social_insurance_employee DECIMAL(12,2) DEFAULT 0,
    employment_insurance DECIMAL(12,2) DEFAULT 0,
    other_deductions JSONB,
    total_deductions DECIMAL(12,2),
    
    -- 差引支給額
    net_pay DECIMAL(12,2),
    
    -- 支払い状況
    payment_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'paid', 'failed'
    payment_method VARCHAR(50), -- 'bank_transfer', 'cash', 'check'
    payment_reference VARCHAR(100),
    
    -- 書類
    payslip_file_url VARCHAR(500),
    
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### **2.2.5 生活支援関連テーブル**

```sql
-- 相談記録テーブル
CREATE TABLE consultation_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    consultation_type VARCHAR(50), -- 'chatbot', 'human_staff', 'video_call'
    category VARCHAR(100), -- 'work', 'life', 'legal', 'cultural', 'emergency'
    subcategory VARCHAR(100),
    
    -- 相談内容
    original_language VARCHAR(10), -- 元の言語
    original_content TEXT, -- 元の相談内容
    translated_content TEXT, -- 翻訳された内容
    
    -- 対応情報
    response_content TEXT, -- 回答内容
    response_language VARCHAR(10),
    response_by VARCHAR(50), -- 'ai_bot', 'human_staff'
    staff_id UUID REFERENCES users(id), -- 対応スタッフ
    
    -- 状況・評価
    urgency_level VARCHAR(20), -- 'low', 'medium', 'high', 'critical'
    status VARCHAR(50) DEFAULT 'open', -- 'open', 'in_progress', 'resolved', 'escalated'
    satisfaction_rating INTEGER, -- 1-5満足度
    resolution_time_minutes INTEGER,
    
    -- フォローアップ
    requires_followup BOOLEAN DEFAULT false,
    followup_date DATE,
    followup_notes TEXT,
    
    -- 企業通知
    company_notified BOOLEAN DEFAULT false,
    company_notification_date TIMESTAMP,
    company_response TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 面談予約・記録テーブル
CREATE TABLE counseling_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    staff_id UUID REFERENCES users(id), -- 面談スタッフ
    
    -- 予約情報
    scheduled_at TIMESTAMP NOT NULL,
    duration_minutes INTEGER DEFAULT 60,
    session_type VARCHAR(50), -- 'regular', 'emergency', 'followup'
    session_language VARCHAR(10),
    session_method VARCHAR(50), -- 'video_call', 'phone', 'in_person'
    
    -- Zoom情報
    zoom_meeting_id VARCHAR(100),
    zoom_join_url VARCHAR(500),
    zoom_password VARCHAR(100),
    
    -- セッション実施
    actual_start_time TIMESTAMP,
    actual_end_time TIMESTAMP,
    actual_duration_minutes INTEGER,
    
    -- 内容記録
    session_topic VARCHAR(255),
    discussion_points TEXT,
    issues_identified TEXT,
    action_items TEXT,
    next_session_needed BOOLEAN DEFAULT false,
    next_session_date DATE,
    
    -- 評価・フィードバック
    staff_evaluation TEXT, -- スタッフからの評価
    user_satisfaction INTEGER, -- 1-5満足度
    user_feedback TEXT,
    cultural_considerations TEXT, -- 文化的配慮事項
    
    -- 企業向け情報
    company_summary TEXT, -- 企業向け要約
    company_action_required BOOLEAN DEFAULT false,
    company_recommendations TEXT,
    urgency_for_company VARCHAR(20), -- 企業対応の緊急度
    
    -- 状況管理
    status VARCHAR(50) DEFAULT 'scheduled', -- 'scheduled', 'completed', 'cancelled', 'no_show'
    cancellation_reason TEXT,
    rescheduled_to TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- レコメンド・生活情報テーブル
CREATE TABLE lifestyle_recommendations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    
    -- レコメンドタイプ
    recommendation_type VARCHAR(100), -- 'restaurant', 'supermarket', 'medical', 'religious', 'transport', 'service'
    category VARCHAR(100),
    subcategory VARCHAR(100),
    
    -- 事業者情報
    business_name VARCHAR(255),
    business_name_original VARCHAR(255), -- 母国語表記
    address VARCHAR(500),
    phone VARCHAR(20),
    website VARCHAR(500),
    
    -- 営業情報
    opening_hours JSONB, -- 営業時間
    holidays JSONB, -- 定休日
    price_range VARCHAR(50), -- 'budget', 'moderate', 'expensive'
    
    -- 特徴・対応
    features JSONB, -- 特徴・サービス
    language_support JSONB, -- 対応言語
    cultural_considerations JSONB, -- 文化的配慮
    halal_certified BOOLEAN DEFAULT false,
    vegetarian_options BOOLEAN DEFAULT false,
    prayer_space_available BOOLEAN DEFAULT false,
    
    -- 評価・レビュー
    rating DECIMAL(3,2), -- 評価（1-5）
    review_count INTEGER DEFAULT 0,
    user_reviews JSONB, -- ユーザーレビュー
    
    -- パーソナライゼーション
    recommended_score DECIMAL(5,2), -- 個人向け推奨スコア
    recommendation_reasons JSONB, -- 推奨理由
    distance_km DECIMAL(8,2), -- 距離
    
    -- 利用履歴
    viewed_at TIMESTAMP,
    clicked_at TIMESTAMP,
    visited BOOLEAN DEFAULT false,
    user_rating INTEGER, -- ユーザーの評価（1-5）
    user_review TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 多言語スタッフ管理テーブル
CREATE TABLE multilingual_staff (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    
    -- スタッフ情報
    staff_type VARCHAR(50), -- 'counselor', 'consultant', 'emergency_support'
    employment_type VARCHAR(50), -- 'full_time', 'part_time', 'freelance'
    
    -- 対応言語・専門分野
    supported_languages JSONB, -- 対応言語リスト
    specialization_areas JSONB, -- 専門分野
    certifications JSONB, -- 資格・認定
    
    -- 稼働情報
    availability_schedule JSONB, -- 対応可能スケジュール
    max_sessions_per_day INTEGER DEFAULT 8,
    session_duration_minutes INTEGER DEFAULT 60,
    
    -- パフォーマンス
    total_sessions INTEGER DEFAULT 0,
    average_rating DECIMAL(3,2),
    response_time_average INTEGER, -- 平均応答時間（分）
    
    -- ステータス
    is_active BOOLEAN DEFAULT true,
    is_available BOOLEAN DEFAULT true,
    last_active_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **2.3 Redis データベース設計**

#### **2.3.1 キャッシュ戦略**

```javascript
// セッション管理
// キー: session:{user_id}
// 値: { userId, email, userType, permissions, companyId, lastActivity }
// TTL: 24時間

// ユーザープロフィールキャッシュ
// キー: user_profile:{user_id}
// 値: ユーザープロフィール情報のJSON
// TTL: 1時間

// 学習進捗キャッシュ
// キー: learning_progress:{user_id}:{content_id}
// 値: 進捗情報のJSON
// TTL: 30分

// 翻訳結果キャッシュ
// キー: translation:{source_lang}:{target_lang}:{hash}
// 値: 翻訳結果
// TTL: 7日

// APIレート制限
// キー: rate_limit:{api_key}:{endpoint}
// 値: リクエスト数
// TTL: 1時間

// チャットボットセッション
// キー: chatbot_session:{user_id}
// 値: 会話履歴・コンテキスト
// TTL: 2時間

// リアルタイム通知
// キー: notifications:{user_id}
// 値: 通知リスト
// TTL: 24時間
```

### **2.4 MongoDB データベース設計**

#### **2.4.1 ログ・分析用コレクション**

```javascript
// ユーザー行動ログ
db.user_activity_logs.insertOne({
    _id: ObjectId(),
    userId: "uuid",
    sessionId: "session_uuid",
    timestamp: new Date(),
    action: "page_view", // "login", "logout", "video_watch", "quiz_attempt", etc.
    resource: "/learning/content/123",
    metadata: {
        userAgent: "Mozilla/5.0...",
        ipAddress: "192.168.1.1",
        location: { country: "JP", city: "Tokyo" },
        duration: 300, // seconds
        additionalData: {}
    },
    createdAt: new Date()
});

// 学習行動分析
db.learning_analytics.insertOne({
    _id: ObjectId(),
    userId: "uuid",
    contentId: "uuid",
    sessionId: "session_uuid",
    eventType: "video_progress", // "video_start", "video_pause", "video_complete", "quiz_start", etc.
    timestamp: new Date(),
    data: {
        currentTime: 120, // seconds
        totalDuration: 600,
        playbackRate: 1.0,
        quality: "720p",
        interactions: [
            { type: "pause", timestamp: 60 },
            { type: "rewind", timestamp: 90, seekTo: 45 }
        ]
    },
    createdAt: new Date()
});

// チャットボット会話ログ
db.chatbot_conversations.insertOne({
    _id: ObjectId(),
    userId: "uuid",
    sessionId: "session_uuid",
    conversationId: "conv_uuid",
    timestamp: new Date(),
    language: "ja",
    userMessage: {
        original: "仕事で困っています",
        translated: "I'm having trouble at work",
        intent: "work_consultation",
        confidence: 0.95
    },
    botResponse: {
        text: "どのような困りごとでしょうか？詳しく教えてください。",
        translated: "What kind of trouble are you having? Please tell me in detail.",
        responseType: "question",
        suggestedActions: ["escalate_to_human", "schedule_consultation"]
    },
    metadata: {
        processingTime: 500, // milliseconds
        aiModel: "gpt-4",
        satisfactionRating: null // filled later
    },
    createdAt: new Date()
});

// システムエラーログ
db.error_logs.insertOne({
    _id: ObjectId(),
    timestamp: new Date(),
    level: "error", // "info", "warn", "error", "fatal"
    service: "lms-service",
    message: "Database connection timeout",
    stack: "Error stack trace...",
    userId: "uuid", // if applicable
    requestId: "req_uuid",
    metadata: {
        endpoint: "/api/learning/progress",
        method: "POST",
        statusCode: 500,
        responseTime: 30000
    },
    createdAt: new Date()
});

// パフォーマンス監視
db.performance_metrics.insertOne({
    _id: ObjectId(),
    timestamp: new Date(),
    service: "matching-service",
    endpoint: "/api/matching/search",
    metrics: {
        responseTime: 150, // milliseconds
        cpuUsage: 45.2, // percentage
        memoryUsage: 512, // MB
        dbQueryTime: 50, // milliseconds
        externalApiTime: 30 // milliseconds
    },
    metadata: {
        requestSize: 2048, // bytes
        responseSize: 4096, // bytes
        concurrent_users: 150
    },
    createdAt: new Date()
});
```

### **2.5 Elasticsearch データベース設計**

#### **2.5.1 インデックス設計**

```json
// 人材検索インデックス
{
  "mappings": {
    "properties": {
      "userId": { "type": "keyword" },
      "userType": { "type": "keyword" },
      "profile": {
        "properties": {
          "name": { "type": "text", "analyzer": "kuromoji" },
          "age": { "type": "integer" },
          "gender": { "type": "keyword" },
          "nationality": { "type": "keyword" },
          "location": {
            "properties": {
              "prefecture": { "type": "keyword" },
              "city": { "type": "keyword" },
              "coordinates": { "type": "geo_point" }
            }
          }
        }
      },
      "skills": {
        "type": "nested",
        "properties": {
          "category": { "type": "keyword" },
          "name": { "type": "keyword" },
          "level": { "type": "keyword" },
          "experience_years": { "type": "float" },
          "verified": { "type": "boolean" }
        }
      },
      "qualifications": {
        "type": "nested",
        "properties": {
          "type": { "type": "keyword" },
          "name": { "type": "text" },
          "score": { "type": "keyword" },
          "obtained_date": { "type": "date" }
        }
      },
      "work_preferences": {
        "properties": {
          "job_type": { "type": "keyword" },
          "locations": { "type": "keyword" },
          "salary_min": { "type": "integer" },
          "start_date": { "type": "date" }
        }
      },
      "matching_score": { "type": "float" },
      "last_active": { "type": "date" },
      "created_at": { "type": "date" },
      "updated_at": { "type": "date" }
    }
  }
}

// 学習コンテンツ検索インデックス
{
  "mappings": {
    "properties": {
      "contentId": { "type": "keyword" },
      "title": {
        "type": "text",
        "analyzer": "kuromoji",
        "fields": {
          "keyword": { "type": "keyword" }
        }
      },
      "description": { "type": "text", "analyzer": "kuromoji" },
      "category": { "type": "keyword" },
      "subcategory": { "type": "keyword" },
      "difficulty_level": { "type": "keyword" },
      "content_type": { "type": "keyword" },
      "duration": { "type": "integer" },
      "tags": { "type": "keyword" },
      "languages": { "type": "keyword" },
      "rating": { "type": "float" },
      "completion_rate": { "type": "float" },
      "prerequisites": { "type": "keyword" },
      "learning_objectives": { "type": "text" },
      "is_published": { "type": "boolean" },
      "created_at": { "type": "date" },
      "updated_at": { "type": "date" }
    }
  }
}
```

---

## **3. API設計**

### **3.1 API設計原則**

#### **3.1.1 RESTful API 設計規約**

**URL構造：**
```
https://api.dx-seed.com/v1/{service}/{resource}
```

**HTTPメソッド使用規則：**
- `GET`: データ取得
- `POST`: 新規作成
- `PUT`: 完全更新
- `PATCH`: 部分更新
- `DELETE`: 削除

**ステータスコード規約：**
- `200`: 成功
- `201`: 作成成功
- `400`: リクエストエラー
- `401`: 認証エラー
- `403`: 認可エラー
- `404`: リソースが見つからない
- `500`: サーバーエラー

#### **3.1.2 共通レスポンス形式**

```typescript
// 成功レスポンス
interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
  metadata?: {
    total?: number;
    page?: number;
    pageSize?: number;
    hasNext?: boolean;
  };
}

// エラーレスポンス
interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any;
  };
  requestId: string;
  timestamp: string;
}
```

### **3.2 認証API**

#### **3.2.1 エンドポイント一覧**

```typescript
// 認証サービス API
interface AuthAPI {
  // ユーザー登録
  'POST /v1/auth/register': {
    body: {
      email: string;
      password: string;
      userType: 'dx_talent' | 'foreign_talent' | 'company_admin' | 'company_employee';
      profile: {
        firstName: string;
        lastName: string;
        phoneNumber?: string;
      };
      companyInfo?: {
        name: string;
        industry: string;
      };
    };
    response: {
      user: User;
      accessToken: string;
      refreshToken: string;
    };
  };

  // ログイン
  'POST /v1/auth/login': {
    body: {
      email: string;
      password: string;
      rememberMe?: boolean;
    };
    response: {
      user: User;
      accessToken: string;
      refreshToken: string;
    };
  };

  // ログアウト
  'POST /v1/auth/logout': {
    headers: {
      Authorization: string;
    };
    response: {
      message: string;
    };
  };

  // トークン更新
  'POST /v1/auth/refresh': {
    body: {
      refreshToken: string;
    };
    response: {
      accessToken: string;
      refreshToken: string;
    };
  };

  // パスワードリセット要求
  'POST /v1/auth/forgot-password': {
    body: {
      email: string;
    };
    response: {
      message: string;
    };
  };

  // パスワードリセット実行
  'POST /v1/auth/reset-password': {
    body: {
      token: string;
      newPassword: string;
    };
    response: {
      message: string;
    };
  };

  // メール認証
  'POST /v1/auth/verify-email': {
    body: {
      token: string;
    };
    response: {
      message: string;
    };
  };

  // 多要素認証設定
  'POST /v1/auth/mfa/setup': {
    headers: {
      Authorization: string;
    };
    response: {
      secret: string;
      qrCode: string;
    };
  };

  // 多要素認証確認
  'POST /v1/auth/mfa/verify': {
    headers: {
      Authorization: string;
    };
    body: {
      code: string;
    };
    response: {
      verified: boolean;
    };
  };
}
```

### **3.3 ユーザー管理API**

```typescript
interface UserAPI {
  // プロフィール取得
  'GET /v1/users/profile': {
    headers: {
      Authorization: string;
    };
    response: UserProfile;
  };

  // プロフィール更新
  'PATCH /v1/users/profile': {
    headers: {
      Authorization: string;
    };
    body: Partial<UserProfile>;
    response: UserProfile;
  };

  // 企業情報取得
  'GET /v1/users/company': {
    headers: {
      Authorization: string;
    };
    response: Company;
  };

  // 企業情報更新
  'PATCH /v1/users/company': {
    headers: {
      Authorization: string;
    };
    body: Partial<Company>;
    response: Company;
  };

  // 従業員一覧取得
  'GET /v1/users/company/employees': {
    headers: {
      Authorization: string;
    };
    query: {
      page?: number;
      pageSize?: number;
      search?: string;
      department?: string;
    };
    response: {
      employees: CompanyUser[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 従業員招待
  'POST /v1/users/company/employees/invite': {
    headers: {
      Authorization: string;
    };
    body: {
      email: string;
      role: string;
      department?: string;
      position?: string;
    };
    response: {
      invitation: EmployeeInvitation;
    };
  };

  // 従業員削除
  'DELETE /v1/users/company/employees/{employeeId}': {
    headers: {
      Authorization: string;
    };
    params: {
      employeeId: string;
    };
    response: {
      message: string;
    };
  };
}
```

### **3.4 LMS API**

```typescript
interface LMSAPI {
  // コンテンツカテゴリ一覧
  'GET /v1/lms/categories': {
    headers: {
      Authorization: string;
    };
    query: {
      language?: string;
      parent_id?: string;
    };
    response: {
      categories: ContentCategory[];
    };
  };

  // 学習コンテンツ一覧
  'GET /v1/lms/contents': {
    headers: {
      Authorization: string;
    };
    query: {
      category_id?: string;
      difficulty?: string;
      content_type?: string;
      language?: string;
      page?: number;
      pageSize?: number;
      search?: string;
    };
    response: {
      contents: LearningContent[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 特定コンテンツ取得
  'GET /v1/lms/contents/{contentId}': {
    headers: {
      Authorization: string;
    };
    params: {
      contentId: string;
    };
    response: LearningContent;
  };

  // 学習進捗取得
  'GET /v1/lms/progress': {
    headers: {
      Authorization: string;
    };
    query: {
      content_id?: string;
      category_id?: string;
    };
    response: {
      progress: LearningProgress[];
      summary: {
        totalContents: number;
        completedContents: number;
        inProgressContents: number;
        totalTimeSpent: number;
        averageScore: number;
      };
    };
  };

  // 学習進捗更新
  'PATCH /v1/lms/progress/{contentId}': {
    headers: {
      Authorization: string;
    };
    params: {
      contentId: string;
    };
    body: {
      progressPercentage?: number;
      timeSpent?: number;
      status?: string;
      notes?: string;
    };
    response: LearningProgress;
  };

  // クイズ開始
  'POST /v1/lms/quizzes/{quizId}/attempts': {
    headers: {
      Authorization: string;
    };
    params: {
      quizId: string;
    };
    response: {
      attempt: QuizAttempt;
      questions: QuizQuestion[];
    };
  };

  // クイズ回答提出
  'POST /v1/lms/quizzes/{quizId}/attempts/{attemptId}/submit': {
    headers: {
      Authorization: string;
    };
    params: {
      quizId: string;
      attemptId: string;
    };
    body: {
      answers: {
        questionId: string;
        answer: any;
      }[];
    };
    response: {
      attempt: QuizAttempt;
      score: number;
      passed: boolean;
      feedback: {
        questionId: string;
        correct: boolean;
        explanation: string;
      }[];
    };
  };

  // 証明書一覧
  'GET /v1/lms/certificates': {
    headers: {
      Authorization: string;
    };
    query: {
      type?: string;
      year?: number;
    };
    response: {
      certificates: Certificate[];
    };
  };

  // 証明書ダウンロード
  'GET /v1/lms/certificates/{certificateId}/download': {
    headers: {
      Authorization: string;
    };
    params: {
      certificateId: string;
    };
    response: Blob; // PDF file
  };

  // 管理者用：コンテンツ作成
  'POST /v1/lms/admin/contents': {
    headers: {
      Authorization: string;
    };
    body: {
      title: string;
      titleTranslations?: Record<string, string>;
      description: string;
      descriptionTranslations?: Record<string, string>;
      categoryId: string;
      contentType: string;
      difficultyLevel: string;
      estimatedDuration: number;
      contentData: any;
      prerequisites?: string[];
    };
    response: LearningContent;
  };

  // 管理者用：コンテンツ更新
  'PATCH /v1/lms/admin/contents/{contentId}': {
    headers: {
      Authorization: string;
    };
    params: {
      contentId: string;
    };
    body: Partial<LearningContent>;
    response: LearningContent;
  };

  // 管理者用：コンテンツ公開/非公開
  'PATCH /v1/lms/admin/contents/{contentId}/publish': {
    headers: {
      Authorization: string;
    };
    params: {
      contentId: string;
    };
    body: {
      isPublished: boolean;
    };
    response: {
      message: string;
    };
  };

  // 企業用：従業員進捗確認
  'GET /v1/lms/company/employees/progress': {
    headers: {
      Authorization: string;
    };
    query: {
      employee_id?: string;
      department?: string;
      content_id?: string;
      date_from?: string;
      date_to?: string;
    };
    response: {
      progress: EmployeeLearningProgress[];
      summary: CompanyLearningStatistics;
    };
  };
}
```

### **3.5 マッチングAPI**

```typescript
interface MatchingAPI {
  // 人材検索
  'GET /v1/matching/talents/search': {
    headers: {
      Authorization: string;
    };
    query: {
      talent_type: 'dx' | 'foreign';
      skills?: string[];
      experience_min?: number;
      experience_max?: number;
      location?: string[];
      availability?: string;
      japanese_level?: string;
      specific_skill_field?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      talents: TalentProfile[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 特定人材詳細（制限付き）
  'GET /v1/matching/talents/{talentId}': {
    headers: {
      Authorization: string;
    };
    params: {
      talentId: string;
    };
    response: TalentProfile; // 企業向け制限情報のみ
  };

  // 面接希望申請
  'POST /v1/matching/talents/{talentId}/interview-request': {
    headers: {
      Authorization: string;
    };
    params: {
      talentId: string;
    };
    body: {
      message: string;
      preferredDates: string[];
      position: string;
      salary?: {
        min: number;
        max: number;
      };
    };
    response: {
      request: InterviewRequest;
    };
  };

  // 求人情報作成
  'POST /v1/matching/job-postings': {
    headers: {
      Authorization: string;
    };
    body: {
      title: string;
      description: string;
      requirements: {
        skills: string[];
        experience: number;
        education?: string;
        japanese_level?: string;
      };
      jobType: string;
      workLocation: string;
      salary: {
        min: number;
        max: number;
        currency: string;
      };
      benefits?: string;
      specificSkillField?: string;
      applicationDeadline?: string;
      startDate?: string;
    };
    response: JobPosting;
  };

  // 求人情報一覧
  'GET /v1/matching/job-postings': {
    headers: {
      Authorization: string;
    };
    query: {
      company_id?: string;
      is_active?: boolean;
      page?: number;
      pageSize?: number;
    };
    response: {
      jobPostings: JobPosting[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // マッチング履歴
  'GET /v1/matching/history': {
    headers: {
      Authorization: string;
    };
    query: {
      status?: string;
      date_from?: string;
      date_to?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      matches: MatchingRecord[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 面接記録作成
  'POST /v1/matching/interviews': {
    headers: {
      Authorization: string;
    };
    body: {
      matchingId: string;
      scheduledAt: string;
      interviewType: string;
      interviewerNotes?: string;
    };
    response: InterviewRecord;
  };

  // 面接記録更新
  'PATCH /v1/matching/interviews/{interviewId}': {
    headers: {
      Authorization: string;
    };
    params: {
      interviewId: string;
    };
    body: {
      actualStartTime?: string;
      actualEndTime?: string;
      interviewerNotes?: string;
      evaluationScore?: number;
      decision?: string;
      nextSteps?: string;
    };
    response: InterviewRecord;
  };
}
```

### **3.6 雇用管理API**

```typescript
interface EmploymentAPI {
  // 雇用契約書テンプレート生成
  'POST /v1/employment/contracts/template': {
    headers: {
      Authorization: string;
    };
    body: {
      talentId: string;
      jobPostingId?: string;
      contractType: string;
      startDate: string;
      endDate?: string;
      salary: {
        amount: number;
        type: string;
      };
      workingHours: {
        hoursPerWeek: number;
        daysPerWeek: number;
      };
    };
    response: {
      contract: EmploymentContract;
      documentUrl: string; // 生成されたPDFのURL
    };
  };

  // 雇用契約一覧
  'GET /v1/employment/contracts': {
    headers: {
      Authorization: string;
    };
    query: {
      employee_id?: string;
      status?: string;
      contract_type?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      contracts: EmploymentContract[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 雇用契約詳細
  'GET /v1/employment/contracts/{contractId}': {
    headers: {
      Authorization: string;
    };
    params: {
      contractId: string;
    };
    response: EmploymentContract;
  };

  // 雇用契約更新
  'PATCH /v1/employment/contracts/{contractId}': {
    headers: {
      Authorization: string;
    };
    params: {
      contractId: string;
    };
    body: Partial<EmploymentContract>;
    response: EmploymentContract;
  };

  // 電子署名
  'POST /v1/employment/contracts/{contractId}/sign': {
    headers: {
      Authorization: string;
    };
    params: {
      contractId: string;
    };
    body: {
      signatureType: 'employee' | 'company';
      signature: string; // Base64エンコードされた署名
    };
    response: {
      message: string;
      signedAt: string;
    };
  };

  // 在留資格申請書類生成
  'POST /v1/employment/visa/application': {
    headers: {
      Authorization: string;
    };
    body: {
      employeeId: string;
      applicationType: 'change' | 'renewal' | 'extension';
      newVisaType: string;
      applicationReason: string;
    };
    response: {
      application: VisaApplication;
      documents: {
        name: string;
        url: string;
        required: boolean;
      }[];
    };
  };

  // 在留資格管理一覧
  'GET /v1/employment/visa/management': {
    headers: {
      Authorization: string;
    };
    query: {
      employee_id?: string;
      status?: string;
      expiry_before?: string;
    };
    response: {
      visaRecords: VisaManagement[];
    };
  };

  // 支援計画書作成
  'POST /v1/employment/support-plans': {
    headers: {
      Authorization: string;
    };
    body: {
      employeeId: string;
      contractId: string;
      planType: 'direct' | 'registered_support_organization';
      registeredSupportOrgId?: string;
      planStartDate: string;
      planEndDate: string;
    };
    response: {
      supportPlan: SupportPlan;
      documentUrl: string;
    };
  };

  // 労働時間記録
  'POST /v1/employment/work-records': {
    headers: {
      Authorization: string;
    };
    body: {
      employeeId: string;
      workDate: string;
      startTime: string;
      endTime: string;
      breakTimeMinutes: number;
      workType: string;
      notes?: string;
    };
    response: WorkRecord;
  };

  // 給与計算
  'POST /v1/employment/payroll/calculate': {
    headers: {
      Authorization: string;
    };
    body: {
      employeeId: string;
      payPeriodStart: string;
      payPeriodEnd: string;
    };
    response: {
      payroll: PayrollCalculation;
      payslipUrl: string;
    };
  };

  // 法定報告書生成
  'POST /v1/employment/reports/legal': {
    headers: {
      Authorization: string;
    };
    body: {
      reportType: 'quarterly' | 'annual';
      period: {
        year: number;
        quarter?: number;
      };
      employeeIds?: string[];
    };
    response: {
      report: LegalReport;
      documentUrl: string;
    };
  };
}
```

### **3.7 生活支援API**

```typescript
interface SupportAPI {
  // チャットボット会話
  'POST /v1/support/chatbot/message': {
    headers: {
      Authorization: string;
    };
    body: {
      message: string;
      language?: string;
      sessionId?: string;
    };
    response: {
      response: string;
      translatedResponse?: string;
      sessionId: string;
      suggestedActions?: string[];
      escalateToHuman?: boolean;
    };
  };

  // 相談履歴
  'GET /v1/support/consultations': {
    headers: {
      Authorization: string;
    };
    query: {
      category?: string;
      status?: string;
      date_from?: string;
      date_to?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      consultations: ConsultationRecord[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 相談記録作成
  'POST /v1/support/consultations': {
    headers: {
      Authorization: string;
    };
    body: {
      category: string;
      subcategory?: string;
      content: string;
      language: string;
      urgencyLevel: string;
    };
    response: ConsultationRecord;
  };

  // レコメンド取得
  'GET /v1/support/recommendations': {
    headers: {
      Authorization: string;
    };
    query: {
      type?: string;
      category?: string;
      location?: string;
      features?: string[];
      maxDistance?: number;
    };
    response: {
      recommendations: LifestyleRecommendation[];
    };
  };

  // レコメンド評価
  'POST /v1/support/recommendations/{recommendationId}/rating': {
    headers: {
      Authorization: string;
    };
    params: {
      recommendationId: string;
    };
    body: {
      rating: number; // 1-5
      review?: string;
      visited: boolean;
    };
    response: {
      message: string;
    };
  };

  // 面談予約可能時間取得
  'GET /v1/support/counseling/availability': {
    headers: {
      Authorization: string;
    };
    query: {
      language: string;
      date_from: string;
      date_to: string;
      session_type?: string;
    };
    response: {
      availability: {
        date: string;
        timeSlots: {
          startTime: string;
          endTime: string;
          staffId: string;
          staffName: string;
        }[];
      }[];
    };
  };

  // 面談予約
  'POST /v1/support/counseling/sessions': {
    headers: {
      Authorization: string;
    };
    body: {
      staffId: string;
      scheduledAt: string;
      sessionType: string;
      sessionLanguage: string;
      topic?: string;
      urgencyLevel?: string;
    };
    response: {
      session: CounselingSession;
      zoomInfo: {
        meetingId: string;
        joinUrl: string;
        password: string;
      };
    };
  };

  // 面談履歴
  'GET /v1/support/counseling/sessions': {
    headers: {
      Authorization: string;
    };
    query: {
      status?: string;
      date_from?: string;
      date_to?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      sessions: CounselingSession[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 面談記録更新（スタッフ用）
  'PATCH /v1/support/counseling/sessions/{sessionId}': {
    headers: {
      Authorization: string;
    };
    params: {
      sessionId: string;
    };
    body: {
      actualStartTime?: string;
      actualEndTime?: string;
      discussionPoints?: string;
      issuesIdentified?: string;
      actionItems?: string;
      staffEvaluation?: string;
      nextSessionNeeded?: boolean;
      nextSessionDate?: string;
      companySummary?: string;
      companyRecommendations?: string;
      urgencyForCompany?: string;
    };
    response: CounselingSession;
  };

  // 企業向け：従業員相談内容確認
  'GET /v1/support/company/employee-consultations': {
    headers: {
      Authorization: string;
    };
    query: {
      employee_id?: string;
      category?: string;
      urgency_level?: string;
      date_from?: string;
      date_to?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      consultations: {
        consultation: ConsultationRecord;
        translatedContent: string;
        summary: string;
        actionRequired: boolean;
        recommendations: string[];
      }[];
      total: number;
      page: number;
      pageSize: number;
    };
  };

  // 企業向け：従業員面談記録確認
  'GET /v1/support/company/employee-sessions': {
    headers: {
      Authorization: string;
    };
    query: {
      employee_id?: string;
      date_from?: string;
      date_to?: string;
      page?: number;
      pageSize?: number;
    };
    response: {
      sessions: {
        session: CounselingSession;
        companySummary: string;
        recommendations: string[];
        urgencyLevel: string;
        actionRequired: boolean;
      }[];
      total: number;
      page: number;
      pageSize: number;
    };
  };
}
```

### **3.8 翻訳API**

```typescript
interface TranslationAPI {
  // テキスト翻訳
  'POST /v1/translation/translate': {
    headers: {
      Authorization: string;
    };
    body: {
      text: string;
      sourceLang?: string; // 自動検出の場合は省略
      targetLang: string;
      domain?: string; // 'general', 'business', 'legal', 'medical'
    };
    response: {
      translatedText: string;
      sourceLang: string;
      targetLang: string;
      confidence: number;
    };
  };

  // 一括翻訳
  'POST /v1/translation/translate/batch': {
    headers: {
      Authorization: string;
    };
    body: {
      texts: string[];
      sourceLang?: string;
      targetLang: string;
      domain?: string;
    };
    response: {
      translations: {
        original: string;
        translated: string;
        confidence: number;
      }[];
      sourceLang: string;
      targetLang: string;
    };
  };

  // 言語検出
  'POST /v1/translation/detect': {
    headers: {
      Authorization: string;
    };
    body: {
      text: string;
    };
    response: {
      language: string;
      confidence: number;
      alternatives: {
        language: string;
        confidence: number;
      }[];
    };
  };

  // 対応言語一覧
  'GET /v1/translation/languages': {
    response: {
      languages: {
        code: string;
        name: string;
        nativeName: string;
        supported: {
          source: boolean;
          target: boolean;
        };
      }[];
    };
  };
}
```

### **3.9 WebSocket API（リアルタイム通信）**

```typescript
// WebSocket接続エンドポイント
// wss://api.dx-seed.com/v1/ws

interface WebSocketAPI {
  // 接続時の認証
  authenticate: {
    type: 'authenticate';
    token: string;
  };

  // チャットボットとのリアルタイム会話
  chatbot_message: {
    type: 'chatbot_message';
    sessionId: string;
    message: string;
    language?: string;
  };

  // リアルタイム通知
  notification: {
    type: 'notification';
    data: {
      id: string;
      title: string;
      message: string;
      category: string;
      urgency: 'low' | 'medium' | 'high' | 'critical';
      timestamp: string;
      actions?: {
        label: string;
        action: string;
        url?: string;
      }[];
    };
  };

  // 学習進捗のリアルタイム更新
  learning_progress: {
    type: 'learning_progress';
    contentId: string;
    progress: number;
    timeSpent: number;
  };

  // 面談中のリアルタイム翻訳
  translation_request: {
    type: 'translation_request';
    sessionId: string;
    text: string;
    sourceLang: string;
    targetLang: string;
  };

  translation_response: {
    type: 'translation_response';
    sessionId: string;
    translatedText: string;
    confidence: number;
  };
}
```

---

## **4. フロントエンド設計**

### **4.1 技術スタック・アーキテクチャ**

#### **4.1.1 技術選定**

```typescript
// 主要技術スタック
const frontendStack = {
  framework: 'React 18.2+',
  language: 'TypeScript 5.0+',
  cssFramework: 'Tailwind CSS 3.0+',
  router: 'React Router 6+',
  stateManagement: 'Zustand + React Query',
  buildTool: 'Vite',
  uiComponents: 'Headless UI + Custom Components',
  formHandling: 'React Hook Form + Zod',
  animation: 'Framer Motion',
  charts: 'Chart.js + React Chartjs 2',
  dateTime: 'date-fns',
  icons: 'Lucide React',
  testing: 'Vitest + React Testing Library'
};
```

#### **4.1.2 プロジェクト構造**

```
src/
├── components/           # 再利用可能なコンポーネント
│   ├── ui/              # 基本UIコンポーネント
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   ├── Modal.tsx
│   │   ├── Loading.tsx
│   │   └── ...
│   ├── forms/           # フォーム関連コンポーネント
│   ├── layout/          # レイアウトコンポーネント
│   └── charts/          # チャート・グラフコンポーネント
├── features/            # 機能別コンポーネント
│   ├── auth/            # 認証関連
│   ├── lms/             # 学習管理システム
│   ├── matching/        # マッチング機能
│   ├── employment/      # 雇用管理
│   ├── support/         # 生活支援
│   └── admin/           # 管理者機能
├── hooks/               # カスタムフック
├── stores/              # 状態管理（Zustand）
├── services/            # API呼び出し・外部サービス
├── utils/               # ユーティリティ関数
├── types/               # TypeScript型定義
├── constants/           # 定数
├── i18n/                # 国際化
└── assets/              # 静的ファイル
```

### **4.2 コンポーネント設計**

#### **4.2.1 共通UIコンポーネント**

```typescript
// Button コンポーネント
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger';
  size?: 'sm' | 'md' | 'lg' | 'xl';
  loading?: boolean;
  disabled?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
  children: React.ReactNode;
  onClick?: () => void;
  type?: 'button' | 'submit' | 'reset';
}

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled = false,
  leftIcon,
  rightIcon,
  fullWidth = false,
  children,
  onClick,
  type = 'button',
  ...props
}) => {
  const baseClasses = 'inline-flex items-center justify-center font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';
  
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500',
    outline: 'border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-blue-500',
    ghost: 'text-blue-600 hover:bg-blue-50 focus:ring-blue-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500'
  };
  
  const sizeClasses = {
    sm: 'px-3 py-1.5 text-sm rounded',
    md: 'px-4 py-2 text-sm rounded-md',
    lg: 'px-6 py-3 text-base rounded-md',
    xl: 'px-8 py-4 text-lg rounded-lg'
  };
  
  const className = clsx(
    baseClasses,
    variantClasses[variant],
    sizeClasses[size],
    fullWidth && 'w-full',
    (disabled || loading) && 'opacity-50 cursor-not-allowed'
  );
  
  return (
    <button
      type={type}
      className={className}
      disabled={disabled || loading}
      onClick={onClick}
      {...props}
    >
      {loading ? (
        <Loader2 className="w-4 h-4 animate-spin mr-2" />
      ) : leftIcon ? (
        <span className="mr-2">{leftIcon}</span>
      ) : null}
      {children}
      {rightIcon && !loading && (
        <span className="ml-2">{rightIcon}</span>
      )}
    </button>
  );
};

// Input コンポーネント
interface InputProps {
  label?: string;
  error?: string;
  hint?: string;
  required?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  loading?: boolean;
}

export const Input: React.FC<InputProps & React.InputHTMLAttributes<HTMLInputElement>> = ({
  label,
  error,
  hint,
  required,
  leftIcon,
  rightIcon,
  loading,
  className,
  ...props
}) => {
  const inputClasses = clsx(
    'block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500',
    leftIcon && 'pl-10',
    rightIcon && 'pr-10',
    error && 'border-red-300 focus:border-red-500 focus:ring-red-500',
    className
  );
  
  return (
    <div>
      {label && (
        <label className="block text-sm font-medium text-gray-700 mb-1">
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </label>
      )}
      <div className="relative">
        {leftIcon && (
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            {leftIcon}
          </div>
        )}
        <input
          className={inputClasses}
          {...props}
        />
        {(rightIcon || loading) && (
          <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
            {loading ? (
              <Loader2 className="w-4 h-4 animate-spin text-gray-400" />
            ) : (
              rightIcon
            )}
          </div>
        )}
      </div>
      {error && (
        <p className="mt-1 text-sm text-red-600">{error}</p>
      )}
      {hint && !error && (
        <p className="mt-1 text-sm text-gray-500">{hint}</p>
      )}
    </div>
  );
};

// Modal コンポーネント
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  description?: string;
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  children: React.ReactNode;
}

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  description,
  size = 'md',
  children
}) => {
  const sizeClasses = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-2xl',
    xl: 'max-w-4xl',
    full: 'max-w-7xl'
  };
  
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className={clsx(
                'w-full transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all',
                sizeClasses[size]
              )}>
                {title && (
                  <Dialog.Title as="h3" className="text-lg font-medium leading-6 text-gray-900 mb-2">
                    {title}
                  </Dialog.Title>
                )}
                {description && (
                  <Dialog.Description className="text-sm text-gray-500 mb-4">
                    {description}
                  </Dialog.Description>
                )}
                {children}
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
};
```

#### **4.2.2 レイアウトコンポーネント**

```typescript
// メインレイアウト
interface MainLayoutProps {
  children: React.ReactNode;
  sidebar?: React.ReactNode;
  header?: React.ReactNode;
}

export const MainLayout: React.FC<MainLayoutProps> = ({
  children,
  sidebar,
  header
}) => {
  return (
    <div className="min-h-screen bg-gray-50">
      {header && (
        <header className="bg-white shadow-sm border-b border-gray-200">
          {header}
        </header>
      )}
      <div className="flex">
        {sidebar && (
          <aside className="w-64 bg-white shadow-sm border-r border-gray-200 min-h-screen">
            {sidebar}
          </aside>
        )}
        <main className="flex-1 p-6">
          {children}
        </main>
      </div>
    </div>
  );
};

// ダッシュボードレイアウト
export const DashboardLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user } = useAuthStore();
  const [sidebarOpen, setSidebarOpen] = useState(false);
  
  return (
    <MainLayout
      header={<DashboardHeader onMenuClick={() => setSidebarOpen(true)} />}
      sidebar={<DashboardSidebar isOpen={sidebarOpen} onClose={() => setSidebarOpen(false)} />}
    >
      {children}
    </MainLayout>
  );
};

// ヘッダーコンポーネント
interface DashboardHeaderProps {
  onMenuClick: () => void;
}

const DashboardHeader: React.FC<DashboardHeaderProps> = ({ onMenuClick }) => {
  const { user, logout } = useAuthStore();
  const { t, i18n } = useTranslation();
  
  return (
    <div className="flex items-center justify-between px-6 py-4">
      <div className="flex items-center">
        <Button
          variant="ghost"
          size="sm"
          onClick={onMenuClick}
          className="lg:hidden"
        >
          <Menu className="w-5 h-5" />
        </Button>
        <h1 className="text-xl font-semibold text-gray-900 ml-4">
          DX Seed Platform
        </h1>
      </div>
      
      <div className="flex items-center space-x-4">
        {/* 言語切り替え */}
        <LanguageSwitcher />
        
        {/* 通知 */}
        <NotificationDropdown />
        
        {/* ユーザーメニュー */}
        <UserDropdown user={user} onLogout={logout} />
      </div>
    </div>
  );
};

// サイドバーコンポーネント
interface DashboardSidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

const DashboardSidebar: React.FC<DashboardSidebarProps> = ({ isOpen, onClose }) => {
  const { user } = useAuthStore();
  const { t } = useTranslation();
  
  const navigationItems = useMemo(() => {
    const baseItems = [
      { name: t('dashboard'), href: '/dashboard', icon: Home },
      { name: t('profile'), href: '/profile', icon: User }
    ];
    
    // ユーザータイプに応じてナビゲーション項目を追加
    if (user?.userType === 'dx_talent' || user?.userType === 'foreign_talent') {
      baseItems.push(
        { name: t('learning'), href: '/learning', icon: BookOpen },
        { name: t('matching'), href: '/matching', icon: Users },
        { name: t('projects'), href: '/projects', icon: Briefcase }
      );
      
      if (user.userType === 'foreign_talent') {
        baseItems.push(
          { name: t('support'), href: '/support', icon: MessageCircle },
          { name: t('recommendations'), href: '/recommendations', icon: Star }
        );
      }
    }
    
    if (user?.userType === 'company_admin' || user?.userType === 'company_employee') {
      baseItems.push(
        { name: t('employees'), href: '/employees', icon: Users },
        { name: t('training'), href: '/training', icon: BookOpen },
        { name: t('hiring'), href: '/hiring', icon: UserPlus }
      );
      
      if (user.userType === 'company_admin') {
        baseItems.push(
          { name: t('employment_management'), href: '/employment', icon: FileText },
          { name: t('reports'), href: '/reports', icon: BarChart3 }
        );
      }
    }
    
    if (user?.userType === 'admin') {
      baseItems.push(
        { name: t('content_management'), href: '/admin/content', icon: BookOpen },
        { name: t('user_management'), href: '/admin/users', icon: Users },
        { name: t('system_analytics'), href: '/admin/analytics', icon: BarChart3 },
        { name: t('settings'), href: '/admin/settings', icon: Settings }
      );
    }
    
    return baseItems;
  }, [user, t]);
  
  return (
    <>
      {/* モバイル用オーバーレイ */}
      {isOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40 lg:hidden"
          onClick={onClose}
        />
      )}
      
      <div className={clsx(
        'fixed inset-y-0 left-0 z-50 w-64 bg-white shadow-lg transform transition-transform duration-300 ease-in-out lg:translate-x-0 lg:static',
        isOpen ? 'translate-x-0' : '-translate-x-full'
      )}>
        <div className="flex flex-col h-full">
          <div className="flex-1 flex flex-col pt-5 pb-4 overflow-y-auto">
            <nav className="mt-5 flex-1 px-2 space-y-1">
              {navigationItems.map((item) => (
                <NavLink
                  key={item.name}
                  to={item.href}
                  className={({ isActive }) => clsx(
                    'group flex items-center px-2 py-2 text-sm font-medium rounded-md transition-colors',
                    isActive
                      ? 'bg-blue-100 text-blue-900'
                      : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                  )}
                  onClick={() => onClose()}
                >
                  <item.icon className="mr-3 h-6 w-6" />
                  {item.name}
                </NavLink>
              ))}
            </nav>
          </div>
        </div>
      </div>
    </>
  );
};
```

### **4.3 状態管理設計**

#### **4.3.1 Zustand ストア設計**

```typescript
// 認証ストア
interface AuthState {
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

interface AuthActions {
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
  updateUser: (user: Partial<User>) => void;
  setLoading: (loading: boolean) => void;
}

export const useAuthStore = create<AuthState & AuthActions>((set, get) => ({
  user: null,
  accessToken: null,
  refreshToken: null,
  isAuthenticated: false,
  isLoading: true,
  
  login: async (credentials) => {
    try {
      set({ isLoading: true });
      const response = await authService.login(credentials);
      
      // トークンをセキュアストレージに保存
      await secureStorage.setItem('accessToken', response.accessToken);
      await secureStorage.setItem('refreshToken', response.refreshToken);
      
      set({
        user: response.user,
        accessToken: response.accessToken,
        refreshToken: response.refreshToken,
        isAuthenticated: true,
        isLoading: false
      });
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },
  
  logout: () => {
    secureStorage.removeItem('accessToken');
    secureStorage.removeItem('refreshToken');
    
    set({
      user: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,
      isLoading: false
    });
  },
  
  refreshToken: async () => {
    try {
      const currentRefreshToken = get().refreshToken;
      if (!currentRefreshToken) throw new Error('No refresh token');
      
      const response = await authService.refreshToken(currentRefreshToken);
      
      await secureStorage.setItem('accessToken', response.accessToken);
      await secureStorage.setItem('refreshToken', response.refreshToken);
      
      set({
        accessToken: response.accessToken,
        refreshToken: response.refreshToken
      });
    } catch (error) {
      get().logout();
      throw error;
    }
  },
  
  updateUser: (userData) => {
    set((state) => ({
      user: state.user ? { ...state.user, ...userData } : null
    }));
  },
  
  setLoading: (loading) => {
    set({ isLoading: loading });
  }
}));

// UI状態ストア
interface UIState {
  sidebarOpen: boolean;
  notifications: Notification[];
  modals: Record<string, boolean>;
  language: string;
  theme: 'light' | 'dark';
}

interface UIActions {
  toggleSidebar: () => void;
  setSidebarOpen: (open: boolean) => void;
  addNotification: (notification: Notification) => void;
  removeNotification: (id: string) => void;
  openModal: (modalId: string) => void;
  closeModal: (modalId: string) => void;
  setLanguage: (language: string) => void;
  setTheme: (theme: 'light' | 'dark') => void;
}

export const useUIStore = create<UIState & UIActions>((set) => ({
  sidebarOpen: false,
  notifications: [],
  modals: {},
  language: 'ja',
  theme: 'light',
  
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  setSidebarOpen: (open) => set({ sidebarOpen: open }),
  
  addNotification: (notification) => set((state) => ({
    notifications: [...state.notifications, notification]
  })),
  
  removeNotification: (id) => set((state) => ({
    notifications: state.notifications.filter(n => n.id !== id)
  })),
  
  openModal: (modalId) => set((state) => ({
    modals: { ...state.modals, [modalId]: true }
  })),
  
  closeModal: (modalId) => set((state) => ({
    modals: { ...state.modals, [modalId]: false }
  })),
  
  setLanguage: (language) => {
    set({ language });
    i18n.changeLanguage(language);
    localStorage.setItem('language', language);
  },
  
  setTheme: (theme) => {
    set({ theme });
    localStorage.setItem('theme', theme);
  }
}));
```

#### **4.3.2 React Query設定**

```typescript
// React Query設定
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: (failureCount, error: any) => {
        // 認証エラーの場合はリトライしない
        if (error?.response?.status === 401) return false;
        return failureCount < 3;
      },
      staleTime: 5 * 60 * 1000, // 5分
      cacheTime: 10 * 60 * 1000, // 10分
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});

// カスタムフック例
export const useUserProfile = () => {
  const { user } = useAuthStore();
  
  return useQuery({
    queryKey: ['user', 'profile', user?.id],
    queryFn: () => userService.getProfile(),
    enabled: !!user?.id,
    staleTime: 10 * 60 * 1000, // 10分
  });
};

export const useLearningProgress = (contentId?: string) => {
  const { user } = useAuthStore();
  
  return useQuery({
    queryKey: ['learning', 'progress', user?.id, contentId],
    queryFn: () => lmsService.getProgress(contentId),
    enabled: !!user?.id,
    refetchInterval: 30 * 1000, // 30秒ごとに更新
  });
};

export const useUpdateProfile = () => {
  const queryClient = useQueryClient();
  const { updateUser } = useAuthStore();
  
  return useMutation({
    mutationFn: userService.updateProfile,
    onSuccess: (data) => {
      // ストアを更新
      updateUser(data);
      
      // キャッシュを無効化
      queryClient.invalidateQueries(['user', 'profile']);
      
      // 成功通知
      toast.success('プロフィールを更新しました');
    },
    onError: (error: any) => {
      toast.error(error.message || 'プロフィールの更新に失敗しました');
    },
  });
};
```

### **4.4 国際化（i18n）設計**

#### **4.4.1 i18n設定**

```typescript
// i18n設定
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

// 対応言語
export const supportedLanguages = {
  ja: '日本語',
  en: 'English',
  zh: '中文',
  vi: 'Tiếng Việt',
  fil: 'Filipino',
  id: 'Bahasa Indonesia',
  th: 'ไทย',
  my: 'မြန်မာ',
  km: 'ខ្មែរ',
  ne: 'नेपाली',
  mn: 'Монгол'
};

i18n
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    fallbackLng: 'ja',
    debug: process.env.NODE_ENV === 'development',
    
    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage'],
    },
    
    interpolation: {
      escapeValue: false,
    },
    
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },
    
    react: {
      useSuspense: false,
    },
  });

export default i18n;

// 翻訳ファイル例（日本語）
// /public/locales/ja/common.json
{
  "dashboard": "ダッシュボード",
  "profile": "プロフィール",
  "learning": "学習",
  "matching": "マッチング",
  "projects": "案件",
  "support": "サポート",
  "recommendations": "おすすめ",
  "employees": "従業員",
  "training": "研修",
  "hiring": "採用",
  "employment_management": "雇用管理",
  "reports": "レポート",
  "content_management": "コンテンツ管理",
  "user_management": "ユーザー管理",
  "system_analytics": "システム分析",
  "settings": "設定",
  "login": "ログイン",
  "logout": "ログアウト",
  "register": "新規登録",
  "email": "メールアドレス",
  "password": "パスワード",
  "confirm_password": "パスワード確認",
  "first_name": "名",
  "last_name": "姓",
  "phone_number": "電話番号",
  "save": "保存",
  "cancel": "キャンセル",
  "edit": "編集",
  "delete": "削除",
  "search": "検索",
  "loading": "読み込み中...",
  "error": "エラーが発生しました",
  "success": "成功しました",
  "required_field": "必須項目です",
  "invalid_email": "有効なメールアドレスを入力してください",
  "password_too_short": "パスワードは8文字以上で入力してください"
}

// 言語切り替えコンポーネント
export const LanguageSwitcher: React.FC = () => {
  const { i18n } = useTranslation();
  const [isOpen, setIsOpen] = useState(false);
  
  const handleLanguageChange = (language: string) => {
    i18n.changeLanguage(language);
    setIsOpen(false);
  };
  
  return (
    <div className="relative">
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center space-x-2"
      >
        <Globe className="w-4 h-4" />
        <span>{supportedLanguages[i18n.language as keyof typeof supportedLanguages]}</span>
        <ChevronDown className="w-4 h-4" />
      </Button>
      
      {isOpen && (
        <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg ring-1 ring-black ring-opacity-5 z-10">
          <div className="py-1">
            {Object.entries(supportedLanguages).map(([code, name]) => (
              <button
                key={code}
                onClick={() => handleLanguageChange(code)}
                className={clsx(
                  'block w-full text-left px-4 py-2 text-sm hover:bg-gray-100',
                  i18n.language === code && 'bg-blue-50 text-blue-900'
                )}
              >
                {name}
              </button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### **4.5 フォーム処理設計**

#### **4.5.1 React Hook Form + Zod**

```typescript
// バリデーションスキーマ
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z.string().min(8, 'パスワードは8文字以上で入力してください'),
  rememberMe: z.boolean().optional(),
});

export const userProfileSchema = z.object({
  firstName: z.string().min(1, '名は必須です'),
  lastName: z.string().min(1, '姓は必須です'),
  firstNameKana: z.string().optional(),
  lastNameKana: z.string().optional(),
  birthDate: z.string().optional(),
  gender: z.enum(['male', 'female', 'other']).optional(),
  phone: z.string().optional(),
  address: z.object({
    country: z.string().optional(),
    prefecture: z.string().optional(),
    city: z.string().optional(),
    street: z.string().optional(),
    postalCode: z.string().optional(),
  }).optional(),
});

export const foreignTalentResumeSchema = z.object({
  // 基本情報
  nativeName: z.string().min(1, '母国語名は必須です'),
  romajiName: z.string().min(1, 'ローマ字名は必須です'),
  katakanaName: z.string().min(1, 'カタカナ名は必須です'),
  
  // パスポート情報
  passportNumber: z.string().min(1, 'パスポート番号は必須です'),
  passportIssuedDate: z.string().min(1, '発行日は必須です'),
  passportExpiryDate: z.string().min(1, '有効期限は必須です'),
  
  // 身体情報
  height: z.number().min(100).max(250).optional(),
  weight: z.number().min(30).max(200).optional(),
  bloodType: z.enum(['A', 'B', 'O', 'AB']).optional(),
  
  // 生活習慣
  smoking: z.enum(['never', 'former', 'current']).optional(),
  drinking: z.enum(['never', 'occasionally', 'regularly']).optional(),
  religion: z.string().optional(),
  
  // 特定技能関連
  desiredSkillFields: z.array(z.string()).min(1, '希望分野を最低1つ選択してください'),
  
  // 志望動機
  motivationForJapan: z.string().min(100, '100文字以上で入力してください'),
  selfIntroduction: z.string().min(100, '100文字以上で入力してください'),
});

// フォームコンポーネント例
interface LoginFormProps {
  onSubmit: (data: z.infer<typeof loginSchema>) => Promise<void>;
  loading?: boolean;
}

export const LoginForm: React.FC<LoginFormProps> = ({ onSubmit, loading = false }) => {
  const { t } = useTranslation();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setError,
  } = useForm<z.infer<typeof loginSchema>>({
    resolver: zodResolver(loginSchema),
  });
  
  const handleFormSubmit = async (data: z.infer<typeof loginSchema>) => {
    try {
      await onSubmit(data);
    } catch (error: any) {
      if (error.field) {
        setError(error.field, { message: error.message });
      } else {
        toast.error(error.message || 'ログインに失敗しました');
      }
    }
  };
  
  return (
    <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">
      <Input
        label={t('email')}
        type="email"
        required
        {...register('email')}
        error={errors.email?.message}
        leftIcon={<Mail className="w-4 h-4 text-gray-400" />}
      />
      
      <Input
        label={t('password')}
        type="password"
        required
        {...register('password')}
        error={errors.password?.message}
        leftIcon={<Lock className="w-4 h-4 text-gray-400" />}
      />
      
      <div className="flex items-center">
        <input
          id="rememberMe"
          type="checkbox"
          {...register('rememberMe')}
          className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
        />
        <label htmlFor="rememberMe" className="ml-2 block text-sm text-gray-900">
          {t('remember_me')}
        </label>
      </div>
      
      <Button
        type="submit"
        variant="primary"
        size="lg"
        fullWidth
        loading={loading}
      >
        {t('login')}
      </Button>
    </form>
  );
};

// 海外人材履歴書フォーム（複数ステップ）
export const ForeignTalentResumeForm: React.FC = () => {
  const { t } = useTranslation();
  const [currentStep, setCurrentStep] = useState(1);
  const totalSteps = 6;
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    setValue,
    trigger,
  } = useForm<z.infer<typeof foreignTalentResumeSchema>>({
    resolver: zodResolver(foreignTalentResumeSchema),
    mode: 'onChange',
  });
  
  const onSubmit = async (data: z.infer<typeof foreignTalentResumeSchema>) => {
    try {
      await resumeService.updateResume(data);
      toast.success('履歴書を保存しました');
    } catch (error: any) {
      toast.error('保存に失敗しました');
    }
  };
  
  const nextStep = async () => {
    const fieldsToValidate = getFieldsForStep(currentStep);
    const isValid = await trigger(fieldsToValidate);
    
    if (isValid && currentStep < totalSteps) {
      setCurrentStep(currentStep + 1);
    }
  };
  
  const prevStep = () => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1);
    }
  };
  
  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return <BasicInfoStep register={register} errors={errors} />;
      case 2:
        return <PassportInfoStep register={register} errors={errors} />;
      case 3:
        return <PhysicalInfoStep register={register} errors={errors} />;
      case 4:
        return <LifestyleInfoStep register={register} errors={errors} />;
      case 5:
        return <SkillFieldsStep register={register} errors={errors} setValue={setValue} watch={watch} />;
      case 6:
        return <MotivationStep register={register} errors={errors} />;
      default:
        return null;
    }
  };
  
  return (
    <div className="max-w-2xl mx-auto">
      {/* プログレスバー */}
      <div className="mb-8">
        <div className="flex items-center justify-between">
          {Array.from({ length: totalSteps }, (_, i) => (
            <div
              key={i}
              className={clsx(
                'w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium',
                i + 1 <= currentStep
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-200 text-gray-600'
              )}
            >
              {i + 1}
            </div>
          ))}
        </div>
        <div className="mt-2 h-2 bg-gray-200 rounded-full">
          <div
            className="h-2 bg-blue-600 rounded-full transition-all duration-300"
            style={{ width: `${(currentStep / totalSteps) * 100}%` }}
          />
        </div>
      </div>
      
      <form onSubmit={handleSubmit(onSubmit)}>
        {renderStep()}
        
        <div className="mt-8 flex justify-between">
          <Button
            type="button"
            variant="outline"
            onClick={prevStep}
            disabled={currentStep === 1}
          >
            {t('previous')}
          </Button>
          
          {currentStep === totalSteps ? (
            <Button type="submit" variant="primary">
              {t('save_resume')}
            </Button>
          ) : (
            <Button type="button" variant="primary" onClick={nextStep}>
              {t('next')}
            </Button>
          )}
        </div>
      </form>
    </div>
  );
};
```

### **4.6 リアルタイム通信設計**

#### **4.6.1 WebSocket接続管理**

```typescript
// WebSocket管理フック
interface UseWebSocketOptions {
  url: string;
  protocols?: string[];
  onOpen?: (event: Event) => void;
  onMessage?: (data: any) => void;
  onError?: (event: Event) => void;
  onClose?: (event: CloseEvent) => void;
  shouldReconnect?: boolean;
  reconnectAttempts?: number;
  reconnectInterval?: number;
}

export const useWebSocket = (options: UseWebSocketOptions) => {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [reconnectCount, setReconnectCount] = useState(0);
  const { accessToken } = useAuthStore();
  
  const connect = useCallback(() => {
    if (socket?.readyState === WebSocket.OPEN) return;
    
    const ws = new WebSocket(options.url, options.protocols);
    
    ws.onopen = (event) => {
      setIsConnected(true);
      setReconnectCount(0);
      
      // 認証
      if (accessToken) {
        ws.send(JSON.stringify({
          type: 'authenticate',
          token: accessToken
        }));
      }
      
      options.onOpen?.(event);
    };
    
    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        options.onMessage?.(data);
      } catch (error) {
        console.error('WebSocket message parse error:', error);
      }
    };
    
    ws.onerror = (event) => {
      console.error('WebSocket error:', event);
      options.onError?.(event);
    };
    
    ws.onclose = (event) => {
      setIsConnected(false);
      setSocket(null);
      options.onClose?.(event);
      
      // 自動再接続
      if (options.shouldReconnect && reconnectCount < (options.reconnectAttempts || 5)) {
        setTimeout(() => {
          setReconnectCount(prev => prev + 1);
          connect();
        }, options.reconnectInterval || 3000);
      }
    };
    
    setSocket(ws);
  }, [options, accessToken, reconnectCount]);
  
  const disconnect = useCallback(() => {
    socket?.close();
  }, [socket]);
  
  const sendMessage = useCallback((message: any) => {
    if (socket?.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    }
  }, [socket]);
  
  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);
  
  return {
    isConnected,
    sendMessage,
    disconnect,
    reconnect: connect
  };
};

// チャットボット用WebSocket
export const useChatbotWebSocket = () => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isTyping, setIsTyping] = useState(false);
  
  const { sendMessage, isConnected } = useWebSocket({
    url: `${process.env.REACT_APP_WS_URL}/chatbot`,
    shouldReconnect: true,
    onMessage: (data) => {
      switch (data.type) {
        case 'chatbot_response':
          setMessages(prev => [...prev, {
            id: generateId(),
            content: data.response,
            sender: 'bot',
            timestamp: new Date(),
            language: data.language
          }]);
          setIsTyping(false);
          break;
          
        case 'chatbot_typing':
          setIsTyping(true);
          break;
          
        case 'error':
          toast.error(data.message);
          setIsTyping(false);
          break;
      }
    }
  });
  
  const sendChatMessage = (message: string, language?: string) => {
    const userMessage: ChatMessage = {
      id: generateId(),
      content: message,
      sender: 'user',
      timestamp: new Date(),
      language: language || 'ja'
    };
    
    setMessages(prev => [...prev, userMessage]);
    setIsTyping(true);
    
    sendMessage({
      type: 'chatbot_message',
      message,
      language,
      sessionId: sessionStorage.getItem('chatSessionId') || generateId()
    });
  };
  
  return {
    messages,
    isTyping,
    isConnected,
    sendMessage: sendChatMessage
  };
};

// 通知用WebSocket
export const useNotificationWebSocket = () => {
  const { addNotification } = useUIStore();
  
  useWebSocket({
    url: `${process.env.REACT_APP_WS_URL}/notifications`,
    shouldReconnect: true,
    onMessage: (data) => {
      if (data.type === 'notification') {
        addNotification({
          id: data.data.id,
          title: data.data.title,
          message: data.data.message,
          type: data.data.category,
          timestamp: new Date(data.data.timestamp)
        });
        
        // ブラウザ通知
        if (Notification.permission === 'granted') {
          new Notification(data.data.title, {
            body: data.data.message,
            icon: '/favicon.ico'
          });
        }
      }
    }
  });
};
```

### **4.7 チャート・データ可視化設計**

#### **4.7.1 チャートコンポーネント**

```typescript
// 学習進捗チャート
interface LearningProgressChartProps {
  data: LearningProgressData[];
  className?: string;
}

export const LearningProgressChart: React.FC<LearningProgressChartProps> = ({ 
  data, 
  className 
}) => {
  const chartData = {
    labels: data.map(item => item.date),
    datasets: [
      {
        label: '学習時間（時間）',
        data: data.map(item => item.studyHours),
        borderColor: 'rgb(59, 130, 246)',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        tension: 0.4,
      },
      {
        label: '完了コンテンツ数',
        data: data.map(item => item.completedContents),
        borderColor: 'rgb(16, 185, 129)',
        backgroundColor: 'rgba(16, 185, 129, 0.1)',
        tension: 0.4,
        yAxisID: 'y1',
      },
    ],
  };
  
  const options = {
    responsive: true,
    interaction: {
      mode: 'index' as const,
      intersect: false,
    },
    scales: {
      x: {
        display: true,
        title: {
          display: true,
          text: '日付',
        },
      },
      y: {
        type: 'linear' as const,
        display: true,
        position: 'left' as const,
        title: {
          display: true,
          text: '学習時間（時間）',
        },
      },
      y1: {
        type: 'linear' as const,
        display: true,
        position: 'right' as const,
        title: {
          display: true,
          text: 'コンテンツ数',
        },
        grid: {
          drawOnChartArea: false,
        },
      },
    },
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: '学習進捗',
      },
    },
  };
  
  return (
    <div className={clsx('p-4 bg-white rounded-lg shadow', className)}>
      <Line data={chartData} options={options} />
    </div>
  );
};

// スキル分布レーダーチャート
interface SkillRadarChartProps {
  skills: SkillData[];
  className?: string;
}

export const SkillRadarChart: React.FC<SkillRadarChartProps> = ({ 
  skills, 
  className 
}) => {
  const chartData = {
    labels: skills.map(skill => skill.name),
    datasets: [
      {
        label: '現在のレベル',
        data: skills.map(skill => skill.currentLevel),
        borderColor: 'rgb(59, 130, 246)',
        backgroundColor: 'rgba(59, 130, 246, 0.2)',
        pointBackgroundColor: 'rgb(59, 130, 246)',
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: 'rgb(59, 130, 246)',
      },
      {
        label: '目標レベル',
        data: skills.map(skill => skill.targetLevel),
        borderColor: 'rgb(16, 185, 129)',
        backgroundColor: 'rgba(16, 185, 129, 0.2)',
        pointBackgroundColor: 'rgb(16, 185, 129)',
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: 'rgb(16, 185, 129)',
      },
    ],
  };
  
  const options = {
    responsive: true,
    scales: {
      r: {
        beginAtZero: true,
        max: 5,
        ticks: {
          stepSize: 1,
        },
      },
    },
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: 'スキル分布',
      },
    },
  };
  
  return (
    <div className={clsx('p-4 bg-white rounded-lg shadow', className)}>
      <Radar data={chartData} options={options} />
    </div>
  );
};

// マッチング成功率円グラフ
interface MatchingStatsChartProps {
  stats: MatchingStats;
  className?: string;
}

export const MatchingStatsChart: React.FC<MatchingStatsChartProps> = ({ 
  stats, 
  className 
}) => {
  const chartData = {
    labels: ['成功', '進行中', '不成功'],
    datasets: [
      {
        data: [stats.successful, stats.pending, stats.failed],
        backgroundColor: [
          'rgba(16, 185, 129, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(239, 68, 68, 0.8)',
        ],
        borderColor: [
          'rgb(16, 185, 129)',
          'rgb(245, 158, 11)',
          'rgb(239, 68, 68)',
        ],
        borderWidth: 2,
      },
    ],
  };
  
  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'bottom' as const,
      },
      title: {
        display: true,
        text: 'マッチング成功率',
      },
      tooltip: {
        callbacks: {
          label: (context: any) => {
            const total = context.dataset.data.reduce((a: number, b: number) => a + b, 0);
            const percentage = ((context.parsed / total) * 100).toFixed(1);
            return `${context.label}: ${context.parsed} (${percentage}%)`;
          },
        },
      },
    },
  };
  
  return (
    <div className={clsx('p-4 bg-white rounded-lg shadow', className)}>
      <Doughnut data={chartData} options={options} />
    </div>
  );
};

// ダッシュボード統計カード
interface StatCardProps {
  title: string;
  value: string | number;
  change?: {
    value: number;
    type: 'increase' | 'decrease';
    period: string;
  };
  icon?: React.ReactNode;
  className?: string;
}

export const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  change,
  icon,
  className
}) => {
  return (
    <div className={clsx('p-6 bg-white rounded-lg shadow', className)}>
      <div className="flex items-center">
        <div className="flex-1">
          <p className="text-sm text-gray-600">{title}</p>
          <p className="text-2xl font-bold text-gray-900">{value}</p>
          {change && (
            <p className="flex items-center text-sm">
              {change.type === 'increase' ? (
                <TrendingUp className="w-4 h-4 text-green-500 mr-1" />
              ) : (
                <TrendingDown className="w-4 h-4 text-red-500 mr-1" />
              )}
              <span className={clsx(
                'font-medium',
                change.type === 'increase' ? 'text-green-600' : 'text-red-600'
              )}>
                {change.value > 0 ? '+' : ''}{change.value}%
              </span>
              <span className="text-gray-500 ml-1">{change.period}</span>
            </p>
          )}
        </div>
        {icon && (
          <div className="ml-4 text-gray-400">
            {icon}
          </div>
        )}
      </div>
    </div>
  );
};
```

### **4.8 エラーハンドリング・ローディング設計**

#### **4.8.1 エラーバウンダリ**

```typescript
// エラーバウンダリコンポーネント
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

export class ErrorBoundary extends Component<
  { children: ReactNode; fallback?: ComponentType<ErrorBoundaryState> },
  ErrorBoundaryState
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    
    // エラー報告サービスに送信
    errorReportingService.reportError(error, {
      componentStack: errorInfo.componentStack,
      errorBoundary: true,
    });
  }
  
  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent {...this.state} />;
    }
    
    return this.props.children;
  }
}

// デフォルトエラーフォールバック
const DefaultErrorFallback: React.FC<ErrorBoundaryState> = ({ error }) => {
  const { t } = useTranslation();
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6 text-center">
        <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
          <AlertTriangle className="h-6 w-6 text-red-600" />
        </div>
        <h3 className="mt-4 text-lg font-medium text-gray-900">
          {t('error_occurred')}
        </h3>
        <p className="mt-2 text-sm text-gray-500">
          {t('error_please_refresh')}
        </p>
        {process.env.NODE_ENV === 'development' && error && (
          <details className="mt-4 text-left">
            <summary className="cursor-pointer text-sm text-gray-600">
              エラー詳細
            </summary>
            <pre className="mt-2 text-xs text-red-600 bg-red-50 p-2 rounded overflow-auto">
              {error.toString()}
            </pre>
          </details>
        )}
        <div className="mt-6">
          <Button
            variant="primary"
            onClick={() => window.location.reload()}
          >
            {t('refresh_page')}
          </Button>
        </div>
      </div>
    </div>
  );
};

// API エラーハンドリング
export const useErrorHandler = () => {
  const { addNotification } = useUIStore();
  const { logout } = useAuthStore();
  
  return useCallback((error: any) => {
    console.error('API Error:', error);
    
    if (error.response?.status === 401) {
      // 認証エラー
      logout();
      addNotification({
        id: generateId(),
        type: 'error',
        title: 'セッションが期限切れです',
        message: '再度ログインしてください。',
        timestamp: new Date(),
      });
      return;
    }
    
    if (error.response?.status === 403) {
      // 認可エラー
      addNotification({
        id: generateId(),
        type: 'error',
        title: 'アクセス権限がありません',
        message: 'この操作を実行する権限がありません。',
        timestamp: new Date(),
      });
      return;
    }
    
    if (error.response?.status >= 500) {
      // サーバーエラー
      addNotification({
        id: generateId(),
        type: 'error',
        title: 'サーバーエラー',
        message: 'しばらく時間をおいてから再度お試しください。',
        timestamp: new Date(),
      });
      return;
    }
    
    // その他のエラー
    const message = error.response?.data?.message || error.message || '予期しないエラーが発生しました。';
    addNotification({
      id: generateId(),
      type: 'error',
      title: 'エラー',
      message,
      timestamp: new Date(),
    });
  }, [addNotification, logout]);
};
```

#### **4.8.2 ローディング管理**

```typescript
// ローディングコンポーネント
interface LoadingProps {
  size?: 'sm' | 'md' | 'lg';
  text?: string;
  overlay?: boolean;
  className?: string;
}

export const Loading: React.FC<LoadingProps> = ({
  size = 'md',
  text,
  overlay = false,
  className
}) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  };
  
  const content = (
    <div className={clsx('flex flex-col items-center justify-center', className)}>
      <Loader2 className={clsx('animate-spin text-blue-600', sizeClasses[size])} />
      {text && (
        <p className="mt-2 text-sm text-gray-600">{text}</p>
      )}
    </div>
  );
  
  if (overlay) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white rounded-lg p-6">
          {content}
        </div>
      </div>
    );
  }
  
  return content;
};

// ページローディング
export const PageLoading: React.FC<{ text?: string }> = ({ text = '読み込み中...' }) => {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <Loading size="lg" text={text} />
    </div>
  );
};

// スケルトンローディング
export const SkeletonCard: React.FC = () => {
  return (
    <div className="bg-white rounded-lg shadow p-6 animate-pulse">
      <div className="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
      <div className="h-6 bg-gray-200 rounded w-1/2 mb-2"></div>
      <div className="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
      <div className="h-4 bg-gray-200 rounded w-1/3"></div>
    </div>
  );
};

export const SkeletonTable: React.FC<{ rows?: number; cols?: number }> = ({ 
  rows = 5, 
  cols = 4 
}) => {
  return (
    <div className="bg-white rounded-lg shadow overflow-hidden">
      <div className="px-6 py-4 border-b border-gray-200">
        <div className="h-6 bg-gray-200 rounded w-1/3 animate-pulse"></div>
      </div>
      <div className="divide-y divide-gray-200">
        {Array.from({ length: rows }, (_, i) => (
          <div key={i} className="px-6 py-4 flex space-x-4">
            {Array.from({ length: cols }, (_, j) => (
              <div key={j} className="flex-1">
                <div className="h-4 bg-gray-200 rounded animate-pulse"></div>
              </div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

// データフェッチングフック（ローディング状態付き）
export const useAsyncData = <T>(
  fetchFn: () => Promise<T>,
  deps: any[] = []
) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  const handleError = useErrorHandler();
  
  useEffect(() => {
    let isCancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const result = await fetchFn();
        
        if (!isCancelled) {
          setData(result);
        }
      } catch (err: any) {
        if (!isCancelled) {
          setError(err);
          handleError(err);
        }
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      isCancelled = true;
    };
  }, deps);
  
  return { data, loading, error, refetch: () => fetchData() };
};
```

### **4.9 アクセシビリティ・PWA対応**

#### **4.9.1 アクセシビリティ対応**

```typescript
// アクセシブルなコンポーネント例
interface AccessibleButtonProps extends ButtonProps {
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

export const AccessibleButton: React.FC<AccessibleButtonProps> = ({
  ariaLabel,
  ariaDescribedBy,
  children,
  ...props
}) => {
  return (
    <Button
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
      {...props}
    >
      {children}
    </Button>
  );
};

// キーボードナビゲーション対応
export const useKeyboardNavigation = (
  items: { id: string; element: HTMLElement | null }[],
  options: {
    loop?: boolean;
    onSelect?: (id: string) => void;
  } = {}
) => {
  const [focusedIndex, setFocusedIndex] = useState(0);
  
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        setFocusedIndex(prev => {
          const next = prev + 1;
          return options.loop ? next % items.length : Math.min(next, items.length - 1);
        });
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        setFocusedIndex(prev => {
          const next = prev - 1;
          return options.loop ? (next + items.length) % items.length : Math.max(next, 0);
        });
        break;
        
      case 'Enter':
      case ' ':
        event.preventDefault();
        const selectedItem = items[focusedIndex];
        if (selectedItem && options.onSelect) {
          options.onSelect(selectedItem.id);
        }
        break;
    }
  }, [items, focusedIndex, options]);
  
  useEffect(() => {
    const currentItem = items[focusedIndex];
    if (currentItem?.element) {
      currentItem.element.focus();
    }
  }, [focusedIndex, items]);
  
  return { focusedIndex, handleKeyDown };
};

// スクリーンリーダー対応
export const ScreenReaderOnly: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <span className="sr-only">
      {children}
    </span>
  );
};

// フォーカス管理
export const useFocusTrap = (isActive: boolean) => {
  const containerRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    if (!isActive || !containerRef.current) return;
    
    const container = containerRef.current;
    const focusableElements = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
    
    const handleTabKey = (event: KeyboardEvent) => {
      if (event.key !== 'Tab') return;
      
      if (event.shiftKey) {
        if (document.activeElement === firstElement) {
          lastElement.focus();
          event.preventDefault();
        }
      } else {
        if (document.activeElement === lastElement) {
          firstElement.focus();
          event.preventDefault();
        }
      }
    };
    
    container.addEventListener('keydown', handleTabKey);
    firstElement?.focus();
    
    return () => {
      container.removeEventListener('keydown', handleTabKey);
    };
  }, [isActive]);
  
  return containerRef;
};
```

#### **4.9.2 PWA対応**

```typescript
// Service Worker 登録
export const registerServiceWorker = () => {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js')
        .then((registration) => {
          console.log('SW registered: ', registration);
        })
        .catch((registrationError) => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }
};

// オフライン対応フック
export const useOnlineStatus = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return isOnline;
};

// インストール促進
export const useInstallPrompt = () => {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const [showInstallPrompt, setShowInstallPrompt] = useState(false);
  
  useEffect(() => {
    const handleBeforeInstallPrompt = (event: any) => {
      event.preventDefault();
      setDeferredPrompt(event);
      setShowInstallPrompt(true);
    };
    
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    };
  }, []);
  
  const installApp = async () => {
    if (!deferredPrompt) return;
    
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    
    if (outcome === 'accepted') {
      console.log('PWA installed');
    }
    
    setDeferredPrompt(null);
    setShowInstallPrompt(false);
  };
  
  return { showInstallPrompt, installApp };
};

// オフライン通知コンポーネント
export const OfflineNotification: React.FC = () => {
  const isOnline = useOnlineStatus();
  const [wasOffline, setWasOffline] = useState(false);
  
  useEffect(() => {
    if (!isOnline) {
      setWasOffline(true);
    }
  }, [isOnline]);
  
  if (isOnline && wasOffline) {
    setTimeout(() => setWasOffline(false), 3000);
  }
  
  return (
    <>
      {!isOnline && (
        <div className="fixed top-0 left-0 right-0 bg-yellow-500 text-white p-2 text-center z-50">
          <Wifi className="inline w-4 h-4 mr-2" />
          オフラインです。一部の機能が制限されます。
        </div>
      )}
      {isOnline && wasOffline && (
        <div className="fixed top-0 left-0 right-0 bg-green-500 text-white p-2 text-center z-50">
          <CheckCircle className="inline w-4 h-4 mr-2" />
          オンラインに復帰しました。
        </div>
      )}
    </>
  );
};
```

---

## **5. バックエンド設計**

### **5.1 マイクロサービス詳細設計**

#### **5.1.1 共通設計パターン**

```typescript
// 共通エラーハンドリング
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;
  public readonly isOperational: boolean;
  
  constructor(message: string, statusCode: number, code: string, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, field?: string) {
    super(message, 400, 'VALIDATION_ERROR');
    this.field = field;
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404, 'NOT_FOUND');
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = 'Unauthorized') {
    super(message, 401, 'UNAUTHORIZED');
  }
}

// 共通レスポンスユーティリティ
export const sendSuccess = <T>(res: Response, data: T, message?: string, metadata?: any) => {
  return res.status(200).json({
    success: true,
    data,
    message,
    metadata,
    timestamp: new Date().toISOString()
  });
};

export const sendError = (res: Response, error: AppError, requestId?: string) => {
  return res.status(error.statusCode).json({
    success: false,
    error: {
      code: error.code,
      message: error.message,
      ...(error.field && { field: error.field })
    },
    requestId,
    timestamp: new Date().toISOString()
  });
};

// 共通ミドルウェア
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  let appError: AppError;
  
  if (error instanceof AppError) {
    appError = error;
  } else if (error.name === 'ValidationError') {
    appError = new ValidationError(error.message);
  } else if (error.name === 'CastError') {
    appError = new ValidationError('Invalid ID format');
  } else {
    appError = new AppError('Internal server error', 500, 'INTERNAL_ERROR', false);
  }
  
  // ログ出力
  logger.error({
    error: {
      message: appError.message,
      stack: appError.stack,
      statusCode: appError.statusCode,
      code: appError.code
    },
    request: {
      method: req.method,
      url: req.url,
      headers: req.headers,
      body: req.body,
      user: req.user
    }
  });
  
  sendError(res, appError, req.requestId);
};

export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// リクエストIDミドルウェア
export const requestId = (req: Request, res: Response, next: NextFunction) => {
  req.requestId = uuidv4();
  res.setHeader('X-Request-ID', req.requestId);
  next();
};

// レート制限ミドルウェア
export const createRateLimit = (windowMs: number, max: number) => {
  return rateLimit({
    windowMs,
    max,
    message: {
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        message: 'Too many requests, please try again later'
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
  });
};
```

#### **5.1.2 認証サービス詳細**

```typescript
// 認証サービス - JWT管理
export class JWTService {
  private readonly accessTokenSecret: string;
  private readonly refreshTokenSecret: string;
  private readonly accessTokenExpiry: string;
  private readonly refreshTokenExpiry: string;
  
  constructor() {
    this.accessTokenSecret = process.env.ACCESS_TOKEN_SECRET!;
    this.refreshTokenSecret = process.env.REFRESH_TOKEN_SECRET!;
    this.accessTokenExpiry = process.env.ACCESS_TOKEN_EXPIRY || '15m';
    this.refreshTokenExpiry = process.env.REFRESH_TOKEN_EXPIRY || '7d';
  }
  
  generateAccessToken(payload: any): string {
    return jwt.sign(payload, this.accessTokenSecret, {
      expiresIn: this.accessTokenExpiry,
      issuer: 'dx-seed',
      audience: 'dx-seed-users'
    });
  }
  
  generateRefreshToken(payload: any): string {
    return jwt.sign(payload, this.refreshTokenSecret, {
      expiresIn: this.refreshTokenExpiry,
      issuer: 'dx-seed',
      audience: 'dx-seed-users'
    });
  }
  
  verifyAccessToken(token: string): any {
    try {
      return jwt.verify(token, this.accessTokenSecret);
    } catch (error) {
      throw new UnauthorizedError('Invalid access token');
    }
  }
  
  verifyRefreshToken(token: string): any {
    try {
      return jwt.verify(token, this.refreshTokenSecret);
    } catch (error) {
      throw new UnauthorizedError('Invalid refresh token');
    }
  }
}

// 認証ミドルウェア
export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedError('Access token required');
    }
    
    const token = authHeader.substring(7);
    const jwtService = new JWTService();
    const decoded = jwtService.verifyAccessToken(token);
    
    // ユーザー情報を取得
    const user = await userRepository.findById(decoded.userId);
    if (!user) {
      throw new UnauthorizedError('User not found');
    }
    
    req.user = user;
    next();
  } catch (error) {
    next(error);
  }
};

// 認可ミドルウェア
export const authorize = (permissions: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new UnauthorizedError());
    }
    
    const userPermissions = req.user.permissions || [];
    const hasPermission = permissions.some(permission => 
      userPermissions.includes(permission)
    );
    
    if (!hasPermission) {
      return next(new AppError('Insufficient permissions', 403, 'FORBIDDEN'));
    }
    
    next();
  };
};

// 認証コントローラー
export class AuthController {
  private userService: UserService;
  private jwtService: JWTService;
  private passwordService: PasswordService;
  
  constructor() {
    this.userService = new UserService();
    this.jwtService = new JWTService();
    this.passwordService = new PasswordService();
  }
  
  register = asyncHandler(async (req: Request, res: Response) => {
    const { email, password, userType, profile, companyInfo } = req.body;
    
    // バリデーション
    const validationSchema = z.object({
      email: z.string().email(),
      password: z.string().min(8),
      userType: z.enum(['dx_talent', 'foreign_talent', 'company_admin', 'company_employee']),
      profile: z.object({
        firstName: z.string(),
        lastName: z.string(),
        phoneNumber: z.string().optional()
      }),
      companyInfo: z.object({
        name: z.string(),
        industry: z.string()
      }).optional()
    });
    
    const validatedData = validationSchema.parse(req.body);
    
    // 既存ユーザーチェック
    const existingUser = await this.userService.findByEmail(email);
    if (existingUser) {
      throw new ValidationError('Email already registered', 'email');
    }
    
    // パスワードハッシュ化
    const hashedPassword = await this.passwordService.hash(password);
    
    // ユーザー作成
    const user = await this.userService.create({
      ...validatedData,
      password: hashedPassword
    });
    
    // トークン生成
    const accessToken = this.jwtService.generateAccessToken({ userId: user.id });
    const refreshToken = this.jwtService.generateRefreshToken({ userId: user.id });
    
    // リフレッシュトークンを保存
    await this.userService.saveRefreshToken(user.id, refreshToken);
    
    sendSuccess(res, {
      user: this.userService.sanitizeUser(user),
      accessToken,
      refreshToken
    });
  });
  
  login = asyncHandler(async (req: Request, res: Response) => {
    const { email, password, rememberMe } = req.body;
    
    // バリデーション
    const validationSchema = z.object({
      email: z.string().email(),
      password: z.string(),
      rememberMe: z.boolean().optional()
    });
    
    const validatedData = validationSchema.parse(req.body);
    
    // ユーザー認証
    const user = await this.userService.authenticate(email, password);
    if (!user) {
      throw new UnauthorizedError('Invalid credentials');
    }
    
    // トークン生成
    const accessToken = this.jwtService.generateAccessToken({ userId: user.id });
    const refreshToken = this.jwtService.generateRefreshToken({ userId: user.id });
    
    // リフレッシュトークンを保存
    await this.userService.saveRefreshToken(user.id, refreshToken);
    
    // 最終ログイン時刻更新
    await this.userService.updateLastLogin(user.id);
    
    sendSuccess(res, {
      user: this.userService.sanitizeUser(user),
      accessToken,
      refreshToken
    });
  });
  
  refreshToken = asyncHandler(async (req: Request, res: Response) => {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      throw new UnauthorizedError('Refresh token required');
    }
    
    // トークン検証
    const decoded = this.jwtService.verifyRefreshToken(refreshToken);
    
    // リフレッシュトークンの有効性確認
    const isValid = await this.userService.validateRefreshToken(decoded.userId, refreshToken);
    if (!isValid) {
      throw new UnauthorizedError('Invalid refresh token');
    }
    
    // 新しいトークン生成
    const newAccessToken = this.jwtService.generateAccessToken({ userId: decoded.userId });
    const newRefreshToken = this.jwtService.generateRefreshToken({ userId: decoded.userId });
    
    // 新しいリフレッシュトークンを保存
    await this.userService.saveRefreshToken(decoded.userId, newRefreshToken);
    
    sendSuccess(res, {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken
    });
  });
  
  logout = asyncHandler(async (req: Request, res: Response) => {
    const userId = req.user.id;
    
    // リフレッシュトークンを無効化
    await this.userService.revokeRefreshToken(userId);
    
    sendSuccess(res, null, 'Logged out successfully');
  });
}
```

#### **5.1.3 LMSサービス詳細**

```typescript
// LMSサービス - コンテンツ管理
export class LMSService {
  private contentRepository: ContentRepository;
  private progressRepository: ProgressRepository;
  private s3Service: S3Service;
  private transcodeService: TranscodeService;
  
  constructor() {
    this.contentRepository = new ContentRepository();
    this.progressRepository = new ProgressRepository();
    this.s3Service = new S3Service();
    this.transcodeService = new TranscodeService();
  }
  
  async createContent(userId: string, contentData: CreateContentRequest): Promise<LearningContent> {
    // 権限確認
    const user = await userRepository.findById(userId);
    if (!user || !user.permissions.includes('content:create')) {
      throw new AppError('Insufficient permissions', 403, 'FORBIDDEN');
    }
    
    // ファイルアップロード処理
    let fileUrl = null;
    if (contentData.file) {
      fileUrl = await this.s3Service.uploadFile(contentData.file, 'learning-content');
      
      // 動画の場合は変換処理
      if (contentData.contentType === 'video') {
        await this.transcodeService.transcodeVideo(fileUrl);
      }
    }
    
    // コンテンツ作成
    const content = await this.contentRepository.create({
      ...contentData,
      fileUrl,
      createdBy: userId,
      isPublished: false
    });
    
    // Elasticsearch にインデックス
    await this.indexContent(content);
    
    return content;
  }
  
  async getContentList(filters: ContentFilters, pagination: Pagination): Promise<ContentListResponse> {
    // Elasticsearch で検索
    const searchResults = await this.searchContents(filters, pagination);
    
    return {
      contents: searchResults.contents,
      total: searchResults.total,
      page: pagination.page,
      pageSize: pagination.pageSize
    };
  }
  
  async getContentById(contentId: string, userId: string): Promise<LearningContent> {
    const content = await this.contentRepository.findById(contentId);
    if (!content) {
      throw new NotFoundError('Content');
    }
    
    // アクセス権限確認
    const hasAccess = await this.checkContentAccess(userId, contentId);
    if (!hasAccess) {
      throw new AppError('Access denied', 403, 'FORBIDDEN');
    }
    
    return content;
  }
  
  async updateProgress(userId: string, contentId: string, progressData: UpdateProgressRequest): Promise<LearningProgress> {
    // 既存進捗を取得または作成
    let progress = await this.progressRepository.findByUserAndContent(userId, contentId);
    
    if (!progress) {
      progress = await this.progressRepository.create({
        userId,
        contentId,
        status: 'not_started',
        progressPercentage: 0,
        timeSpent: 0
      });
    }
    
    // 進捗更新
    const updatedProgress = await this.progressRepository.update(progress.id, {
      ...progressData,
      lastAccessedAt: new Date()
    });
    
    // 完了判定
    if (progressData.progressPercentage >= 100 && progress.status !== 'completed') {
      await this.progressRepository.update(progress.id, {
        status: 'completed',
        completedAt: new Date()
      });
      
      // 証明書発行判定
      await this.checkCertificateEligibility(userId, contentId);
    }
    
    // 学習分析データ送信
    await this.sendLearningAnalytics(userId, contentId, progressData);
    
    return updatedProgress;
  }
  
  private async checkContentAccess(userId: string, contentId: string): Promise<boolean> {
    const user = await userRepository.findById(userId);
    const content = await this.contentRepository.findById(contentId);
    
    if (!user || !content) return false;
    
    // 管理者は全てにアクセス可能
    if (user.userType === 'admin') return true;
    
    // 公開コンテンツは全員アクセス可能
    if (content.isPublished) return true;
    
    // 企業向けコンテンツの場合、企業のアクセス権限確認
    if (user.userType === 'company_employee' || user.userType === 'company_admin') {
      const companyAccess = await this.contentRepository.checkCompanyAccess(user.companyId, contentId);
      return companyAccess;
    }
    
    return false;
  }
  
  private async indexContent(content: LearningContent): Promise<void> {
    await elasticsearchClient.index({
      index: 'learning_contents',
      id: content.id,
      body: {
        contentId: content.id,
        title: content.title,
        description: content.description,
        category: content.categoryId,
        contentType: content.contentType,
        difficultyLevel: content.difficultyLevel,
        duration: content.estimatedDuration,
        tags: content.tags,
        languages: content.supportedLanguages,
        isPublished: content.isPublished,
        createdAt: content.createdAt,
        updatedAt: content.updatedAt
      }
    });
  }
  
  private async sendLearningAnalytics(userId: string, contentId: string, progressData: any): Promise<void> {
    const analyticsData = {
      userId,
      contentId,
      eventType: 'progress_update',
      timestamp: new Date(),
      data: progressData
    };
    
    // MongoDB に分析データ保存
    await analyticsRepository.saveLearningEvent(analyticsData);
    
    // リアルタイム分析用にキューに送信
    await analyticsQueue.add('learning_progress', analyticsData);
  }
}

// LMSコントローラー
export class LMSController {
  private lmsService: LMSService;
  
  constructor() {
    this.lmsService = new LMSService();
  }
  
  getContentList = asyncHandler(async (req: Request, res: Response) => {
    const filters = {
      categoryId: req.query.category_id as string,
      difficulty: req.query.difficulty as string,
      contentType: req.query.content_type as string,
      language: req.query.language as string,
      search: req.query.search as string
    };
    
    const pagination = {
      page: parseInt(req.query.page as string) || 1,
      pageSize: Math.min(parseInt(req.query.pageSize as string) || 20, 100)
    };
    
    const result = await this.lmsService.getContentList(filters, pagination);
    
    sendSuccess(res, result.contents, undefined, {
      total: result.total,
      page: result.page,
      pageSize: result.pageSize,
      hasNext: result.page * result.pageSize < result.total
    });
  });
  
  getContent = asyncHandler(async (req: Request, res: Response) => {
    const { contentId } = req.params;
    const content = await this.lmsService.getContentById(contentId, req.user.id);
    
    sendSuccess(res, content);
  });
  
  updateProgress = asyncHandler(async (req: Request, res: Response) => {
    const { contentId } = req.params;
    const progressData = req.body;
    
    const progress = await this.lmsService.updateProgress(req.user.id, contentId, progressData);
    
    sendSuccess(res, progress);
  });
  
  getProgress = asyncHandler(async (req: Request, res: Response) => {
    const filters = {
      contentId: req.query.content_id as string,
      categoryId: req.query.category_id as string
    };
    
    const progress = await this.lmsService.getUserProgress(req.user.id, filters);
    
    sendSuccess(res, progress);
  });
}
```

#### **5.1.4 マッチングサービス詳細**

```typescript
// マッチングサービス - AI駆動マッチングアルゴリズム
export class MatchingService {
  private talentRepository: TalentRepository;
  private companyRepository: CompanyRepository;
  private matchingRepository: MatchingRepository;
  private mlService: MLService;
  private notificationService: NotificationService;
  
  constructor() {
    this.talentRepository = new TalentRepository();
    this.companyRepository = new CompanyRepository();
    this.matchingRepository = new MatchingRepository();
    this.mlService = new MLService();
    this.notificationService = new NotificationService();
  }
  
  async searchTalents(companyId: string, filters: TalentSearchFilters, pagination: Pagination): Promise<TalentSearchResponse> {
    // 企業の権限確認
    const company = await this.companyRepository.findById(companyId);
    if (!company) {
      throw new NotFoundError('Company');
    }
    
    // Elasticsearch クエリ構築
    const searchQuery = this.buildTalentSearchQuery(filters);
    
    // 検索実行
    const searchResults = await elasticsearchClient.search({
      index: 'talents',
      body: {
        query: searchQuery,
        from: (pagination.page - 1) * pagination.pageSize,
        size: pagination.pageSize,
        sort: [
          { matching_score: { order: 'desc' } },
          { last_active: { order: 'desc' } }
        ]
      }
    });
    
    // AIマッチングスコア計算
    const talents = await Promise.all(
      searchResults.body.hits.hits.map(async (hit: any) => {
        const talentData = hit._source;
        const matchingScore = await this.mlService.calculateMatchingScore(companyId, talentData.userId);
        
        return {
          ...talentData,
          matchingScore,
          // 企業向けに制限された情報のみ返す
          ...this.sanitizeTalentDataForCompany(talentData)
        };
      })
    );
    
    return {
      talents,
      total: searchResults.body.hits.total.value,
      page: pagination.page,
      pageSize: pagination.pageSize
    };
  }
  
  async requestInterview(companyId: string, talentId: string, interviewRequest: InterviewRequestData): Promise<MatchingRecord> {
    // 既存のマッチング記録確認
    let matchingRecord = await this.matchingRepository.findByCompanyAndTalent(companyId, talentId);
    
    if (!matchingRecord) {
      // 新規マッチング記録作成
      matchingRecord = await this.matchingRepository.create({
        talentUserId: talentId,
        companyId: companyId,
        matchingType: 'dx_talent', // or 'foreign_talent'
        status: 'pending',
        matchingScore: await this.mlService.calculateMatchingScore(companyId, talentId)
      });
    }
    
    // ステータス更新
    await this.matchingRepository.update(matchingRecord.id, {
      status: 'company_interested',
      companyInterestDate: new Date(),
      notes: interviewRequest.message
    });
    
    // 運営者への通知
    await this.notificationService.notifyAdminInterviewRequest({
      matchingId: matchingRecord.id,
      companyId,
      talentId,
      message: interviewRequest.message,
      preferredDates: interviewRequest.preferredDates
    });
    
    // 人材へのマッチング通知（運営を通じて）
    await this.notificationService.notifyTalentInterviewInterest({
      talentId,
      companyName: (await this.companyRepository.findById(companyId))?.name,
      matchingId: matchingRecord.id
    });
    
    return matchingRecord;
  }
  
  async scheduleInterview(matchingId: string, interviewData: InterviewScheduleData, scheduledBy: string): Promise<InterviewRecord> {
    const matching = await this.matchingRepository.findById(matchingId);
    if (!matching) {
      throw new NotFoundError('Matching record');
    }
    
    // 面接記録作成
    const interviewRecord = await interviewRepository.create({
      matchingId,
      interviewType: interviewData.type,
      scheduledAt: interviewData.scheduledAt,
      durationMinutes: interviewData.duration || 60,
      sessionMethod: interviewData.method, // 'video_call', 'phone', 'in_person'
      notes: interviewData.notes,
      createdBy: scheduledBy
    });
    
    // マッチング状況更新
    await this.matchingRepository.update(matchingId, {
      status: 'interview_scheduled',
      interviewScheduledDate: new Date()
    });
    
    // 両者への通知
    await this.notificationService.notifyInterviewScheduled({
      interviewId: interviewRecord.id,
      talentId: matching.talentUserId,
      companyId: matching.companyId,
      scheduledAt: interviewData.scheduledAt
    });
    
    return interviewRecord;
  }
  
  async updateMatchingDecision(matchingId: string, decision: MatchingDecision, updatedBy: string): Promise<MatchingRecord> {
    const matching = await this.matchingRepository.findById(matchingId);
    if (!matching) {
      throw new NotFoundError('Matching record');
    }
    
    const updateData: any = {
      status: decision.status, // 'hired', 'rejected', 'on_hold'
      decisionDate: new Date(),
      notes: decision.notes
    };
    
    if (decision.status === 'rejected') {
      updateData.rejectionReason = decision.rejectionReason;
    }
    
    const updatedMatching = await this.matchingRepository.update(matchingId, updateData);
    
    // 結果通知
    await this.notificationService.notifyMatchingDecision({
      matchingId,
      talentId: matching.talentUserId,
      companyId: matching.companyId,
      decision: decision.status,
      message: decision.notes
    });
    
    // 成功した場合、雇用プロセス開始
    if (decision.status === 'hired') {
      await this.initiateEmploymentProcess(matchingId);
    }
    
    // マッチング学習データ更新
    await this.mlService.updateMatchingFeedback(matchingId, decision.status);
    
    return updatedMatching;
  }
  
  private buildTalentSearchQuery(filters: TalentSearchFilters): any {
    const must: any[] = [];
    const should: any[] = [];
    
    // 基本フィルター
    if (filters.talentType) {
      must.push({ term: { userType: filters.talentType } });
    }
    
    if (filters.skills && filters.skills.length > 0) {
      must.push({
        nested: {
          path: 'skills',
          query: {
            terms: { 'skills.name': filters.skills }
          }
        }
      });
    }
    
    if (filters.location && filters.location.length > 0) {
      should.push({
        terms: { 'profile.location.prefecture': filters.location }
      });
    }
    
    if (filters.experienceMin || filters.experienceMax) {
      const range: any = {};
      if (filters.experienceMin) range.gte = filters.experienceMin;
      if (filters.experienceMax) range.lte = filters.experienceMax;
      
      must.push({
        nested: {
          path: 'skills',
          query: {
            range: { 'skills.experience_years': range }
          }
        }
      });
    }
    
    if (filters.japaneseLevel) {
      must.push({
        nested: {
          path: 'qualifications',
          query: {
            bool: {
              must: [
                { term: { 'qualifications.type': 'japanese_language' } },
                { term: { 'qualifications.score': filters.japaneseLevel } }
              ]
            }
          }
        }
      });
    }
    
    if (filters.specificSkillField) {
      must.push({
        term: { 'work_preferences.specific_skill_field': filters.specificSkillField }
      });
    }
    
    return {
      bool: {
        must,
        should: should.length > 0 ? should : undefined,
        minimum_should_match: should.length > 0 ? 1 : undefined
      }
    };
  }
  
  private sanitizeTalentDataForCompany(talentData: any): any {
    return {
      id: talentData.userId,
      profile: {
        age: talentData.profile.age,
        gender: talentData.profile.gender,
        nationality: talentData.profile.nationality,
        location: {
          prefecture: talentData.profile.location.prefecture
        }
      },
      skills: talentData.skills,
      qualifications: talentData.qualifications.map((q: any) => ({
        type: q.type,
        name: q.name,
        score: q.score,
        obtainedDate: q.obtained_date
      })),
      workPreferences: {
        jobType: talentData.work_preferences.job_type,
        locations: talentData.work_preferences.locations,
        salaryRange: talentData.work_preferences.salary_range,
        startDate: talentData.work_preferences.start_date
      },
      lastActive: talentData.last_active
    };
  }
  
  private async initiateEmploymentProcess(matchingId: string): Promise<void> {
    // 雇用管理サービスに雇用プロセス開始を通知
    await employmentService.startEmploymentProcess(matchingId);
  }
}

// マッチングコントローラー
export class MatchingController {
  private matchingService: MatchingService;
  
  constructor() {
    this.matchingService = new MatchingService();
  }
  
  searchTalents = asyncHandler(async (req: Request, res: Response) => {
    const companyId = req.user.companyId;
    if (!companyId) {
      throw new ValidationError('Company association required');
    }
    
    const filters = {
      talentType: req.query.talent_type as 'dx' | 'foreign',
      skills: req.query.skills ? (req.query.skills as string).split(',') : undefined,
      experienceMin: req.query.experience_min ? parseInt(req.query.experience_min as string) : undefined,
      experienceMax: req.query.experience_max ? parseInt(req.query.experience_max as string) : undefined,
      location: req.query.location ? (req.query.location as string).split(',') : undefined,
      japaneseLevel: req.query.japanese_level as string,
      specificSkillField: req.query.specific_skill_field as string
    };
    
    const pagination = {
      page: parseInt(req.query.page as string) || 1,
      pageSize: Math.min(parseInt(req.query.pageSize as string) || 20, 50)
    };
    
    const result = await this.matchingService.searchTalents(companyId, filters, pagination);
    
    sendSuccess(res, result.talents, undefined, {
      total: result.total,
      page: result.page,
      pageSize: result.pageSize
    });
  });
  
  requestInterview = asyncHandler(async (req: Request, res: Response) => {
    const { talentId } = req.params;
    const companyId = req.user.companyId;
    
    const interviewRequest = {
      message: req.body.message,
      preferredDates: req.body.preferredDates,
      position: req.body.position,
      salary: req.body.salary
    };
    
    const matching = await this.matchingService.requestInterview(companyId, talentId, interviewRequest);
    
    sendSuccess(res, { request: matching });
  });
}
```

#### **5.1.5 雇用管理サービス詳細**

```typescript
// 雇用管理サービス - 書類自動生成
export class EmploymentService {
  private contractRepository: ContractRepository;
  private visaRepository: VisaRepository;
  private documentService: DocumentService;
  private translationService: TranslationService;
  private notificationService: NotificationService;
  
  constructor() {
    this.contractRepository = new ContractRepository();
    this.visaRepository = new VisaRepository();
    this.documentService = new DocumentService();
    this.translationService = new TranslationService();
    this.notificationService = new NotificationService();
  }
  
  async generateEmploymentContract(companyId: string, talentId: string, contractData: ContractData): Promise<EmploymentContractResponse> {
    // 企業・人材情報取得
    const company = await companyRepository.findById(companyId);
    const talent = await userRepository.findById(talentId);
    
    if (!company || !talent) {
      throw new NotFoundError('Company or talent not found');
    }
    
    // 人材の履歴書情報取得
    const resume = await foreignTalentResumeRepository.findByUserId(talentId);
    
    // 契約書データ準備
    const contractTemplate = await this.getContractTemplate(contractData.contractType);
    const populatedContract = await this.populateContractTemplate(contractTemplate, {
      company,
      talent,
      resume,
      contractData
    });
    
    // 契約書レコード作成
    const contract = await this.contractRepository.create({
      companyId,
      employeeUserId: talentId,
      contractType: contractData.contractType,
      contractNumber: this.generateContractNumber(),
      startDate: contractData.startDate,
      endDate: contractData.endDate,
      jobTitle: contractData.jobTitle,
      baseSalary: contractData.salary.amount,
      salaryType: contractData.salary.type,
      workingHoursPerWeek: contractData.workingHours.hoursPerWeek,
      status: 'draft',
      createdBy: req.user.id
    });
    
    // PDF生成
    const pdfBuffer = await this.documentService.generatePDF(populatedContract, 'employment_contract');
    const contractUrl = await this.documentService.uploadDocument(pdfBuffer, `contracts/${contract.id}.pdf`);
    
    // 契約書URL更新
    await this.contractRepository.update(contract.id, { contractFileUrl: contractUrl });
    
    // 多言語版生成
    const translations = await this.generateContractTranslations(populatedContract, talent.nationality);
    
    return {
      contract: { ...contract, contractFileUrl: contractUrl },
      documentUrl: contractUrl,
      translations
    };
  }
  
  async generateVisaApplicationDocuments(employeeId: string, applicationType: string, applicationData: VisaApplicationData): Promise<VisaApplicationResponse> {
    const employee = await userRepository.findById(employeeId);
    const contract = await this.contractRepository.findByEmployeeId(employeeId);
    const resume = await foreignTalentResumeRepository.findByUserId(employeeId);
    
    if (!employee || !contract || !resume) {
      throw new NotFoundError('Required data not found');
    }
    
    // 申請書類テンプレート取得
    const templates = await this.getVisaApplicationTemplates(applicationType);
    
    // 各書類生成
    const documents = await Promise.all(templates.map(async (template) => {
      const populatedDocument = await this.populateVisaTemplate(template, {
        employee,
        contract,
        resume,
        applicationData
      });
      
      const pdfBuffer = await this.documentService.generatePDF(populatedDocument, template.type);
      const documentUrl = await this.documentService.uploadDocument(pdfBuffer, `visa/${employeeId}/${template.filename}`);
      
      return {
        name: template.name,
        type: template.type,
        url: documentUrl,
        required: template.required
      };
    }));
    
    // 在留資格管理レコード作成
    const visaRecord = await this.visaRepository.create({
      employeeUserId: employeeId,
      contractId: contract.id,
      applicationType,
      applicationDate: new Date(),
      appliedVisaType: applicationData.newVisaType,
      applicationReason: applicationData.applicationReason,
      requiredDocuments: templates.map(t => t.name),
      submittedDocuments: documents.map(d => d.name),
      documentStatus: 'complete'
    });
    
    return {
      application: visaRecord,
      documents
    };
  }
  
  async createSupportPlan(employeeId: string, contractId: string, planData: SupportPlanData): Promise<SupportPlan> {
    const contract = await this.contractRepository.findById(contractId);
    if (!contract) {
      throw new NotFoundError('Contract not found');
    }
    
    // 支援計画書生成
    const supportPlan = await supportPlanRepository.create({
      employeeUserId: employeeId,
      contractId,
      planType: planData.planType,
      registeredSupportOrgId: planData.registeredSupportOrgId,
      planStartDate: planData.planStartDate,
      planEndDate: planData.planEndDate,
      
      // 法定支援項目のデフォルト設定
      orientationCompleted: false,
      housingSupport: true,
      lifeguideSupport: true,
      japaneseLearningSuppport: true,
      complaintConsultation: true,
      japaneseContactSupport: true,
      nonJapaneseContactSupport: true,
      notificationSupport: true,
      careerConsultation: true,
      voluntaryDepartureSupport: true,
      
      createdBy: req.user.id
    });
    
    // 支援計画書PDF生成
    const planDocument = await this.generateSupportPlanDocument(supportPlan);
    const documentUrl = await this.documentService.uploadDocument(planDocument, `support-plans/${supportPlan.id}.pdf`);
    
    return { ...supportPlan, documentUrl };
  }
  
  async calculatePayroll(employeeId: string, payPeriodStart: Date, payPeriodEnd: Date): Promise<PayrollCalculation> {
    const contract = await this.contractRepository.findByEmployeeId(employeeId);
    const workRecords = await workRecordRepository.findByEmployeeAndPeriod(employeeId, payPeriodStart, payPeriodEnd);
    
    if (!contract) {
      throw new NotFoundError('Employment contract not found');
    }
    
    // 勤務時間集計
    const totalHours = workRecords.reduce((sum, record) => {
      const workMinutes = record.endTime.getTime() - record.startTime.getTime() - (record.breakTimeMinutes * 60000);
      return sum + (workMinutes / 3600000); // hours
    }, 0);
    
    const regularHours = Math.min(totalHours, contract.workingHoursPerWeek * 4); // 1ヶ月を4週間として計算
    const overtimeHours = Math.max(0, totalHours - regularHours);
    
    // 給与計算
    const regularPay = this.calculateRegularPay(contract.baseSalary, contract.salaryType, regularHours);
    const overtimePay = this.calculateOvertimePay(regularPay, overtimeHours, contract.overtimeRate || 1.25);
    
    // 手当計算
    const allowances = this.calculateAllowances(contract.allowances, workRecords);
    const grossPay = regularPay + overtimePay + allowances.total;
    
    // 控除計算
    const deductions = await this.calculateDeductions(grossPay, contract);
    const netPay = grossPay - deductions.total;
    
    // 給与レコード作成
    const payrollRecord = await payrollRepository.create({
      employeeUserId: employeeId,
      contractId: contract.id,
      payPeriodStart,
      payPeriodEnd,
      payDate: new Date(payPeriodEnd.getTime() + 7 * 24 * 60 * 60 * 1000), // 7日後
      baseSalary: contract.baseSalary,
      regularHours,
      regularPay,
      overtimeHours,
      overtimePay,
      allowances: allowances.details,
      grossPay,
      ...deductions.details,
      totalDeductions: deductions.total,
      netPay,
      paymentStatus: 'pending'
    });
    
    // 給与明細PDF生成
    const payslipBuffer = await this.generatePayslip(payrollRecord);
    const payslipUrl = await this.documentService.uploadDocument(payslipBuffer, `payslips/${payrollRecord.id}.pdf`);
    
    await payrollRepository.update(payrollRecord.id, { payslipFileUrl: payslipUrl });
    
    return { ...payrollRecord, payslipUrl };
  }
  
  async generateLegalReport(reportType: 'quarterly' | 'annual', period: ReportPeriod, employeeIds?: string[]): Promise<LegalReport> {
    let employees: any[];
    
    if (employeeIds) {
      employees = await Promise.all(employeeIds.map(id => userRepository.findById(id)));
    } else {
      employees = await userRepository.findForeignTalentEmployees();
    }
    
    const reportData = await Promise.all(employees.map(async (employee) => {
      const contract = await this.contractRepository.findByEmployeeId(employee.id);
      const visa = await this.visaRepository.findByEmployeeId(employee.id);
      const supportPlan = await supportPlanRepository.findByEmployeeId(employee.id);
      const workRecords = await workRecordRepository.findByEmployeeAndPeriod(employee.id, period.startDate, period.endDate);
      
      return {
        employee,
        contract,
        visa,
        supportPlan,
        workRecords,
        compliance: await this.checkComplianceStatus(employee.id)
      };
    }));
    
    // レポート生成
    const reportTemplate = await this.getLegalReportTemplate(reportType);
    const populatedReport = await this.populateReportTemplate(reportTemplate, reportData, period);
    
    const reportBuffer = await this.documentService.generatePDF(populatedReport, `legal_report_${reportType}`);
    const reportUrl = await this.documentService.uploadDocument(reportBuffer, `reports/${reportType}_${period.year}_${period.quarter || ''}.pdf`);
    
    // レポートレコード作成
    const report = await legalReportRepository.create({
      reportType,
      period,
      employeeCount: employees.length,
      documentUrl: reportUrl,
      generatedBy: req.user.id,
      generatedAt: new Date()
    });
    
    return report;
  }
  
  private async populateContractTemplate(template: string, data: any): Promise<string> {
    // テンプレートエンジン（Handlebars等）を使用してデータを埋め込み
    const compiledTemplate = Handlebars.compile(template);
    return compiledTemplate(data);
  }
  
  private calculateRegularPay(baseSalary: number, salaryType: string, hours: number): number {
    switch (salaryType) {
      case 'monthly':
        return baseSalary;
      case 'hourly':
        return baseSalary * hours;
      case 'annual':
        return baseSalary / 12;
      default:
        throw new ValidationError('Invalid salary type');
    }
  }
  
  private calculateOvertimePay(regularPay: number, overtimeHours: number, overtimeRate: number): number {
    const hourlyRate = regularPay / 160; // 月160時間として計算
    return hourlyRate * overtimeHours * overtimeRate;
  }
  
  private async calculateDeductions(grossPay: number, contract: any): Promise<{ total: number; details: any }> {
    // 所得税計算（簡略化）
    const incomeTax = grossPay * 0.05; // 5%として計算
    
    // 住民税計算
    const residentTax = grossPay * 0.1; // 10%として計算
    
    // 社会保険料計算
    const socialInsurance = grossPay * 0.15; // 15%として計算
    
    // 雇用保険
    const employmentInsurance = grossPay * 0.003; // 0.3%
    
    const total = incomeTax + residentTax + socialInsurance + employmentInsurance;
    
    return {
      total,
      details: {
        incomeTax,
        residentTax,
        socialInsuranceEmployee: socialInsurance,
        employmentInsurance
      }
    };
  }
  
  private generateContractNumber(): string {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const randomNum = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `C${year}${month}${randomNum}`;
  }
}

// 雇用管理コントローラー
export class EmploymentController {
  private employmentService: EmploymentService;
  
  constructor() {
    this.employmentService = new EmploymentService();
  }
  
  generateContract = asyncHandler(async (req: Request, res: Response) => {
    const { talentId } = req.body;
    const companyId = req.user.companyId;
    
    const contractData = {
      contractType: req.body.contractType,
      startDate: new Date(req.body.startDate),
      endDate: req.body.endDate ? new Date(req.body.endDate) : undefined,
      jobTitle: req.body.jobTitle,
      salary: req.body.salary,
      workingHours: req.body.workingHours
    };
    
    const result = await this.employmentService.generateEmploymentContract(companyId, talentId, contractData);
    
    sendSuccess(res, result);
  });
  
  generateVisaApplication = asyncHandler(async (req: Request, res: Response) => {
    const { employeeId } = req.body;
    const applicationType = req.body.applicationType;
    const applicationData = {
      newVisaType: req.body.newVisaType,
      applicationReason: req.body.applicationReason
    };
    
    const result = await this.employmentService.generateVisaApplicationDocuments(employeeId, applicationType, applicationData);
    
    sendSuccess(res, result);
  });
  
  calculatePayroll = asyncHandler(async (req: Request, res: Response) => {
    const { employeeId, payPeriodStart, payPeriodEnd } = req.body;
    
    const result = await this.employmentService.calculatePayroll(
      employeeId,
      new Date(payPeriodStart),
      new Date(payPeriodEnd)
    );
    
    sendSuccess(res, result);
  });
}
```

#### **5.1.6 生活支援サービス詳細**

```typescript
// 生活支援サービス - AI チャットボット
export class SupportService {
  private consultationRepository: ConsultationRepository;
  private sessionRepository: SessionRepository;
  private recommendationRepository: RecommendationRepository;
  private aiService: AIService;
  private translationService: TranslationService;
  private zoomService: ZoomService;
  
  constructor() {
    this.consultationRepository = new ConsultationRepository();
    this.sessionRepository = new SessionRepository();
    this.recommendationRepository = new RecommendationRepository();
    this.aiService = new AIService();
    this.translationService = new TranslationService();
    this.zoomService = new ZoomService();
  }
  
  async processChatbotMessage(userId: string, message: string, language: string, sessionId?: string): Promise<ChatbotResponse> {
    // セッション管理
    if (!sessionId) {
      sessionId = uuidv4();
    }
    
    // ユーザー情報・履歴取得
    const user = await userRepository.findById(userId);
    const chatHistory = await this.getChatHistory(sessionId);
    const userContext = await this.getUserContext(userId);
    
    // メッセージを日本語に翻訳（必要時）
    let translatedMessage = message;
    if (language !== 'ja') {
      const translation = await this.translationService.translate(message, language, 'ja');
      translatedMessage = translation.translatedText;
    }
    
    // 意図分析
    const intent = await this.aiService.analyzeIntent(translatedMessage, chatHistory, userContext);
    
    // 緊急度判定
    const urgencyLevel = await this.aiService.analyzeUrgency(translatedMessage, intent);
    
    // 相談記録作成
    const consultation = await this.consultationRepository.create({
      userId,
      consultationType: 'chatbot',
      category: intent.category,
      subcategory: intent.subcategory,
      originalLanguage: language,
      originalContent: message,
      translatedContent: translatedMessage,
      urgencyLevel,
      status: 'open'
    });
    
    // AI レスポンス生成
    const aiResponse = await this.aiService.generateResponse({
      message: translatedMessage,
      intent,
      userContext,
      chatHistory,
      language
    });
    
    // レスポンスを元の言語に翻訳
    let responseText = aiResponse.response;
    if (language !== 'ja') {
      const translation = await this.translationService.translate(aiResponse.response, 'ja', language);
      responseText = translation.translatedText;
    }
    
    // 相談記録更新
    await this.consultationRepository.update(consultation.id, {
      responseContent: responseText,
      responseLanguage: language,
      responseBy: 'ai_bot'
    });
    
    // 人間スタッフへのエスカレーション判定
    const shouldEscalate = urgencyLevel === 'critical' || 
                          intent.confidence < 0.7 || 
                          aiResponse.confidence < 0.8;
    
    if (shouldEscalate) {
      await this.escalateToHumanStaff(consultation.id, urgencyLevel);
    }
    
    // 企業通知判定
    if (urgencyLevel === 'high' || urgencyLevel === 'critical') {
      await this.notifyCompanyIfNeeded(userId, consultation.id);
    }
    
    return {
      response: responseText,
      sessionId,
      suggestedActions: aiResponse.suggestedActions,
      escalateToHuman: shouldEscalate,
      confidence: aiResponse.confidence
    };
  }
  
  async getPersonalizedRecommendations(userId: string, filters: RecommendationFilters): Promise<LifestyleRecommendation[]> {
    const user = await userRepository.findById(userId);
    const resume = await foreignTalentResumeRepository.findByUserId(userId);
    
    if (!user || !resume) {
      throw new NotFoundError('User profile not found');
    }
    
    // ユーザープロファイル分析
    const userProfile = {
      nationality: user.nationality,
      religion: resume.religion,
      dietaryRestrictions: resume.dietaryRestrictions,
      location: user.address,
      preferences: await this.getUserPreferences(userId)
    };
    
    // 基本検索クエリ
    const searchQuery = this.buildRecommendationQuery(filters, userProfile);
    
    // Elasticsearch 検索
    const searchResults = await elasticsearchClient.search({
      index: 'lifestyle_recommendations',
      body: {
        query: searchQuery,
        size: 50
      }
    });
    
    // パーソナライゼーション
    const recommendations = await Promise.all(
      searchResults.body.hits.hits.map(async (hit: any) => {
        const recommendation = hit._source;
        
        // 個人化スコア計算
        const personalizedScore = await this.calculatePersonalizationScore(recommendation, userProfile);
        
        // 距離計算
        const distance = this.calculateDistance(userProfile.location, recommendation.address);
        
        return {
          ...recommendation,
          personalizedScore,
          distance,
          reasons: this.generateRecommendationReasons(recommendation, userProfile)
        };
      })
    );
    
    // スコア順でソート
    recommendations.sort((a, b) => b.personalizedScore - a.personalizedScore);
    
    return recommendations.slice(0, filters.limit || 20);
  }
  
  async scheduleVideoSession(userId: string, sessionData: SessionScheduleData): Promise<CounselingSession> {
    // スタッフの空き状況確認
    const staff = await multilingualStaffRepository.findById(sessionData.staffId);
    if (!staff) {
      throw new NotFoundError('Staff not found');
    }
    
    const isAvailable = await this.checkStaffAvailability(sessionData.staffId, sessionData.scheduledAt);
    if (!isAvailable) {
      throw new ValidationError('Staff not available at requested time');
    }
    
    // Zoom ミーティング作成
    const zoomMeeting = await this.zoomService.createMeeting({
      topic: `Counseling Session - ${sessionData.topic}`,
      start_time: sessionData.scheduledAt,
      duration: sessionData.durationMinutes || 60,
      settings: {
        waiting_room: true,
        participant_video: true,
        host_video: true
      }
    });
    
    // セッション記録作成
    const session = await this.sessionRepository.create({
      userId,
      staffId: sessionData.staffId,
      scheduledAt: sessionData.scheduledAt,
      durationMinutes: sessionData.durationMinutes || 60,
      sessionType: sessionData.sessionType,
      sessionLanguage: sessionData.sessionLanguage,
      sessionMethod: 'video_call',
      topic: sessionData.topic,
      urgencyLevel: sessionData.urgencyLevel,
      zoomMeetingId: zoomMeeting.id.toString(),
      zoomJoinUrl: zoomMeeting.join_url,
      zoomPassword: zoomMeeting.password,
      status: 'scheduled'
    });
    
    // 通知送信
    await this.notificationService.notifySessionScheduled({
      sessionId: session.id,
      userId,
      staffId: sessionData.staffId,
      scheduledAt: sessionData.scheduledAt
    });
    
    return session;
  }
  
  async updateSessionRecord(sessionId: string, recordData: SessionRecordData, staffId: string): Promise<CounselingSession> {
    const session = await this.sessionRepository.findById(sessionId);
    if (!session || session.staffId !== staffId) {
      throw new NotFoundError('Session not found or access denied');
    }
    
    // セッション記録更新
    const updatedSession = await this.sessionRepository.update(sessionId, {
      actualStartTime: recordData.actualStartTime,
      actualEndTime: recordData.actualEndTime,
      actualDurationMinutes: recordData.actualDurationMinutes,
      discussionPoints: recordData.discussionPoints,
      issuesIdentified: recordData.issuesIdentified,
      actionItems: recordData.actionItems,
      staffEvaluation: recordData.staffEvaluation,
      nextSessionNeeded: recordData.nextSessionNeeded,
      nextSessionDate: recordData.nextSessionDate,
      status: 'completed'
    });
    
    // 企業向け要約生成
    const companySummary = await this.generateCompanySummary(recordData, session.userId);
    const companyRecommendations = await this.generateCompanyRecommendations(recordData, session.userId);
    
    await this.sessionRepository.update(sessionId, {
      companySummary,
      companyRecommendations,
      urgencyForCompany: this.assessCompanyUrgency(recordData)
    });
    
    // 企業通知（必要時）
    if (recordData.companyActionRequired) {
      await this.notifyCompanyOfSessionResults(session.userId, sessionId);
    }
    
    return updatedSession;
  }
  
  async getCompanyEmployeeConsultations(companyId: string, filters: ConsultationFilters): Promise<EmployeeConsultationSummary[]> {
    // 企業の従業員リスト取得
    const employees = await userRepository.findByCompanyId(companyId);
    const employeeIds = employees.map(emp => emp.id);
    
    // 相談記録取得
    const consultations = await this.consultationRepository.findByEmployeeIds(employeeIds, filters);
    
    // 企業向け要約付きで返却
    const summaries = await Promise.all(consultations.map(async (consultation) => {
      const translatedContent = consultation.originalLanguage !== 'ja' 
        ? consultation.translatedContent 
        : consultation.originalContent;
      
      const summary = await this.aiService.generateConsultationSummary(consultation);
      const actionRequired = await this.aiService.assessActionRequired(consultation);
      const recommendations = await this.aiService.generateEmployerRecommendations(consultation);
      
      return {
        consultation,
        translatedContent,
        summary,
        actionRequired,
        recommendations
      };
    }));
    
    return summaries;
  }
  
  private async calculatePersonalizationScore(recommendation: any, userProfile: any): Promise<number> {
    let score = 0;
    
    // 宗教的配慮
    if (userProfile.religion && recommendation.religiousConsiderations) {
      if (recommendation.religiousConsiderations[userProfile.religion]) {
        score += 30;
      }
    }
    
    // 食事制限対応
    if (userProfile.dietaryRestrictions) {
      if (recommendation.halalCertified && userProfile.dietaryRestrictions.includes('halal')) {
        score += 25;
      }
      if (recommendation.vegetarianOptions && userProfile.dietaryRestrictions.includes('vegetarian')) {
        score += 20;
      }
    }
    
    // 言語サポート
    if (recommendation.languageSupport && recommendation.languageSupport.includes(userProfile.nationality)) {
      score += 15;
    }
    
    // 価格帯適合性
    if (userProfile.preferences && userProfile.preferences.priceRange) {
      if (recommendation.priceRange === userProfile.preferences.priceRange) {
        score += 10;
      }
    }
    
    return score;
  }
  
  private async generateCompanySummary(recordData: SessionRecordData, userId: string): Promise<string> {
    const template = `
面談要約:
対象従業員: [従業員ID: ${userId}]
実施日時: ${recordData.actualStartTime}
所要時間: ${recordData.actualDurationMinutes}分

主な議題:
${recordData.discussionPoints}

特定された課題:
${recordData.issuesIdentified}

推奨アクション:
${recordData.actionItems}

スタッフ評価:
${recordData.staffEvaluation}
    `;
    
    return template.trim();
  }
  
  private assessCompanyUrgency(recordData: SessionRecordData): string {
    // 緊急度判定ロジック
    const urgentKeywords = ['退職', 'quit', '辞める', 'problem', '困っている', 'help'];
    const content = `${recordData.discussionPoints} ${recordData.issuesIdentified}`.toLowerCase();
    
    const hasUrgentContent = urgentKeywords.some(keyword => content.includes(keyword));
    
    if (hasUrgentContent || recordData.nextSessionNeeded) {
      return 'high';
    }
    
    return 'medium';
  }
}

// 生活支援コントローラー
export class SupportController {
  private supportService: SupportService;
  
  constructor() {
    this.supportService = new SupportService();
  }
  
  processChatMessage = asyncHandler(async (req: Request, res: Response) => {
    const { message, language, sessionId } = req.body;
    const userId = req.user.id;
    
    const response = await this.supportService.processChatbotMessage(userId, message, language || 'ja', sessionId);
    
    sendSuccess(res, response);
  });
  
  getRecommendations = asyncHandler(async (req: Request, res: Response) => {
    const userId = req.user.id;
    const filters = {
      type: req.query.type as string,
      category: req.query.category as string,
      maxDistance: req.query.maxDistance ? parseInt(req.query.maxDistance as string) : undefined,
      features: req.query.features ? (req.query.features as string).split(',') : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : 20
    };
    
    const recommendations = await this.supportService.getPersonalizedRecommendations(userId, filters);
    
    sendSuccess(res, { recommendations });
  });
  
  scheduleSession = asyncHandler(async (req: Request, res: Response) => {
    const userId = req.user.id;
    const sessionData = {
      staffId: req.body.staffId,
      scheduledAt: new Date(req.body.scheduledAt),
      durationMinutes: req.body.durationMinutes,
      sessionType: req.body.sessionType,
      sessionLanguage: req.body.sessionLanguage,
      topic: req.body.topic,
      urgencyLevel: req.body.urgencyLevel
    };
    
    const session = await this.supportService.scheduleVideoSession(userId, sessionData);
    
    sendSuccess(res, { 
      session,
      zoomInfo: {
        meetingId: session.zoomMeetingId,
        joinUrl: session.zoomJoinUrl,
        password: session.zoomPassword
      }
    });
  });
}
```

---

## **6. AI・機械学習システム設計**

### **6.1 AI サービスアーキテクチャ**

```typescript
// AI統合サービス
export class AIService {
  private openaiClient: OpenAI;
  private sagemakerClient: AWS.SageMaker;
  private comprehendClient: AWS.Comprehend;
  private translateClient: AWS.Translate;
  private mlModelRegistry: MLModelRegistry;
  
  constructor() {
    this.openaiClient = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    this.sagemakerClient = new AWS.SageMaker();
    this.comprehendClient = new AWS.Comprehend();
    this.translateClient = new AWS.Translate();
    this.mlModelRegistry = new MLModelRegistry();
  }
  
  // チャットボット用 自然言語理解
  async analyzeIntent(message: string, chatHistory: ChatMessage[], userContext: UserContext): Promise<IntentAnalysis> {
    const prompt = `
あなたは外国人労働者向けの多言語サポートAIです。以下のメッセージから意図を分析してください。

ユーザーコンテキスト:
- 国籍: ${userContext.nationality}
- 職種: ${userContext.jobType}
- 日本語レベル: ${userContext.japaneseLevel}
- 勤務先: ${userContext.companyType}

過去の会話履歴:
${chatHistory.slice(-5).map(msg => `${msg.sender}: ${msg.content}`).join('\n')}

現在のメッセージ: "${message}"

以下のJSONフォーマットで回答してください:
{
  "category": "work|life|legal|cultural|emergency",
  "subcategory": "具体的なサブカテゴリ",
  "intent": "ユーザーの具体的な意図",
  "urgency": "low|medium|high|critical",
  "confidence": 0.0-1.0の信頼度,
  "entities": ["抽出されたエンティティ"],
  "emotion": "positive|neutral|negative|frustrated|anxious"
}
    `;
    
    const response = await this.openaiClient.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3,
      max_tokens: 500
    });
    
    try {
      const result = JSON.parse(response.choices[0].message.content || '{}');
      return {
        category: result.category,
        subcategory: result.subcategory,
        intent: result.intent,
        urgency: result.urgency,
        confidence: result.confidence,
        entities: result.entities || [],
        emotion: result.emotion
      };
    } catch (error) {
      // フォールバック: AWS Comprehend を使用
      return await this.fallbackIntentAnalysis(message);
    }
  }
  
  // AIレスポンス生成
  async generateResponse(params: ResponseGenerationParams): Promise<AIResponse> {
    const { message, intent, userContext, chatHistory, language } = params;
    
    // コンテキスト情報準備
    const contextInfo = await this.prepareContextInfo(userContext, intent);
    
    const prompt = `
あなたは外国人労働者向けの多言語サポートAIアシスタントです。
以下の情報を基に、適切で有用な回答を生成してください。

ユーザー情報:
- 国籍: ${userContext.nationality}
- 職種: ${userContext.jobType}
- 日本語レベル: ${userContext.japaneseLevel}
- 現在の状況: ${userContext.currentSituation}

意図分析結果:
- カテゴリ: ${intent.category}
- サブカテゴリ: ${intent.subcategory}
- 緊急度: ${intent.urgency}
- 感情: ${intent.emotion}

関連情報:
${contextInfo}

過去の会話:
${chatHistory.slice(-3).map(msg => `${msg.sender}: ${msg.content}`).join('\n')}

ユーザーメッセージ: "${message}"

回答生成の指針:
1. ユーザーの文化的背景を考慮する
2. 日本語レベルに応じた分かりやすい表現を使う
3. 具体的で実践的なアドバイスを提供する
4. 必要に応じて関連リソースを紹介する
5. 温かく親しみやすいトーンを保つ

回答は以下のJSONフォーマットで生成してください:
{
  "response": "メインの回答内容",
  "suggestedActions": ["推奨される具体的なアクション"],
  "relatedResources": ["関連するリソースや情報"],
  "confidence": 0.0-1.0の信頼度,
  "needsHumanSupport": true/false
}
    `;
    
    const response = await this.openaiClient.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.7,
      max_tokens: 1000
    });
    
    try {
      const result = JSON.parse(response.choices[0].message.content || '{}');
      return {
        response: result.response,
        suggestedActions: result.suggestedActions || [],
        relatedResources: result.relatedResources || [],
        confidence: result.confidence || 0.8,
        needsHumanSupport: result.needsHumanSupport || false
      };
    } catch (error) {
      // フォールバック応答
      return {
        response: "申し訳ありませんが、適切な回答を生成できませんでした。人間のスタッフにお繋ぎいたします。",
        suggestedActions: ["人間スタッフとの面談予約"],
        confidence: 0.5,
        needsHumanSupport: true
      };
    }
  }
  
  // マッチングスコア計算
  async calculateMatchingScore(companyId: string, talentId: string): Promise<number> {
    const company = await companyRepository.findById(companyId);
    const talent = await userRepository.findById(talentId);
    const talentProfile = await this.getTalentProfile(talentId);
    
    if (!company || !talent || !talentProfile) {
      return 0;
    }
    
    // 特徴量準備
    const features = {
      // 企業特徴
      company_industry: company.industry,
      company_size: company.employeeCount,
      company_location: company.address.prefecture,
      
      // 人材特徴
      talent_skills: talentProfile.skills,
      talent_experience: talentProfile.totalExperience,
      talent_education: talentProfile.educationLevel,
      talent_japanese_level: talentProfile.japaneseLevel,
      talent_location_preference: talentProfile.locationPreferences,
      
      // マッチング特徴
      skill_overlap: this.calculateSkillOverlap(company.requiredSkills, talentProfile.skills),
      location_distance: this.calculateLocationDistance(company.address, talentProfile.preferredLocation),
      salary_fit: this.calculateSalaryFit(company.salaryRange, talentProfile.expectedSalary)
    };
    
    // SageMaker エンドポイントでスコア計算
    const modelEndpoint = await this.mlModelRegistry.getActiveModel('matching_score');
    
    const response = await this.sagemakerClient.invokeEndpoint({
      EndpointName: modelEndpoint.endpointName,
      ContentType: 'application/json',
      Body: JSON.stringify(features)
    }).promise();
    
    const prediction = JSON.parse(response.Body.toString());
    return Math.round(prediction.score * 100) / 100; // 0-1 の範囲で返す
  }
  
  // 学習効果予測
  async predictLearningOutcome(userId: string, contentId: string): Promise<LearningPrediction> {
    const user = await userRepository.findById(userId);
    const content = await contentRepository.findById(contentId);
    const learningHistory = await this.getLearningHistory(userId);
    
    const features = {
      user_profile: {
        age: user.age,
        education_level: user.educationLevel,
        prior_experience: user.priorExperience,
        japanese_level: user.japaneseLevel
      },
      content_profile: {
        difficulty: content.difficultyLevel,
        duration: content.estimatedDuration,
        content_type: content.contentType,
        prerequisites_met: this.checkPrerequisites(userId, content.prerequisites)
      },
      learning_behavior: {
        avg_session_duration: learningHistory.avgSessionDuration,
        completion_rate: learningHistory.completionRate,
        avg_score: learningHistory.avgScore,
        learning_frequency: learningHistory.frequency
      }
    };
    
    const modelEndpoint = await this.mlModelRegistry.getActiveModel('learning_prediction');
    
    const response = await this.sagemakerClient.invokeEndpoint({
      EndpointName: modelEndpoint.endpointName,
      ContentType: 'application/json',
      Body: JSON.stringify(features)
    }).promise();
    
    const prediction = JSON.parse(response.Body.toString());
    
    return {
      completionProbability: prediction.completion_probability,
      estimatedCompletionTime: prediction.estimated_time,
      recommendedStudyPlan: prediction.study_plan,
      difficultyAdjustment: prediction.difficulty_adjustment
    };
  }
  
  // 離職リスク分析
  async analyzeTurnoverRisk(employeeId: string): Promise<TurnoverRiskAnalysis> {
    const employee = await userRepository.findById(employeeId);
    const workHistory = await workRecordRepository.findByEmployeeId(employeeId);
    const consultationHistory = await consultationRepository.findByUserId(employeeId);
    const performanceData = await this.getPerformanceData(employeeId);
    
    const features = {
      employment_duration: this.calculateEmploymentDuration(employeeId),
      performance_metrics: performanceData,
      consultation_frequency: consultationHistory.length,
      issue_severity: this.analyzeIssuesSeverity(consultationHistory),
      work_satisfaction: this.calculateWorkSatisfaction(consultationHistory),
      attendance_rate: this.calculateAttendanceRate(workHistory),
      overtime_hours: this.calculateOvertimeHours(workHistory),
      japanese_improvement: this.assessJapaneseImprovement(employeeId)
    };
    
    const modelEndpoint = await this.mlModelRegistry.getActiveModel('turnover_prediction');
    
    const response = await this.sagemakerClient.invokeEndpoint({
      EndpointName: modelEndpoint.endpointName,
      ContentType: 'application/json',
      Body: JSON.stringify(features)
    }).promise();
    
    const prediction = JSON.parse(response.Body.toString());
    
    return {
      riskLevel: prediction.risk_level, // 'low', 'medium', 'high', 'critical'
      riskScore: prediction.risk_score, // 0-100
      riskFactors: prediction.risk_factors,
      recommendedActions: prediction.recommended_actions,
      timeframe: prediction.timeframe // 予測される離職時期
    };
  }
  
  // 相談内容要約生成
  async generateConsultationSummary(consultation: ConsultationRecord): Promise<string> {
    const prompt = `
以下の相談内容を簡潔に要約してください。企業の人事担当者が読む用の要約です。

相談者: 外国人従業員
相談カテゴリ: ${consultation.category}
緊急度: ${consultation.urgencyLevel}
相談内容: "${consultation.translatedContent}"

要約は以下の形式で作成してください：
- 相談の概要（1-2文）
- 主な課題点
- 従業員の感情状態
- 推奨される対応

要約:
    `;
    
    const response = await this.openaiClient.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3,
      max_tokens: 300
    });
    
    return response.choices[0].message.content || "要約の生成に失敗しました。";
  }
  
  // 推薦システム用特徴量計算
  async calculateRecommendationFeatures(userId: string, item: any): Promise<RecommendationFeatures> {
    const user = await userRepository.findById(userId);
    const userHistory = await this.getUserInteractionHistory(userId);
    
    return {
      user_preferences: {
        nationality: user.nationality,
        religion: user.religion,
        dietary_restrictions: user.dietaryRestrictions,
        language_preferences: user.languagePreferences
      },
      item_features: {
        category: item.category,
        cultural_compatibility: item.culturalCompatibility,
        language_support: item.languageSupport,
        price_range: item.priceRange
      },
      interaction_features: {
        similar_items_rating: this.calculateSimilarItemsRating(userHistory, item),
        category_preference: this.calculateCategoryPreference(userHistory, item.category),
        recency_bias: this.calculateRecencyBias(userHistory)
      }
    };
  }
  
  private async prepareContextInfo(userContext: UserContext, intent: IntentAnalysis): Promise<string> {
    const contextSources = [
      `関連FAQ: ${await this.getFAQByCategory(intent.category)}`,
      `地域情報: ${await this.getLocationInfo(userContext.location)}`,
      `職種別情報: ${await this.getJobTypeInfo(userContext.jobType)}`,
      `文化的考慮事項: ${await this.getCulturalConsiderations(userContext.nationality)}`
    ];
    
    return contextSources.join('\n');
  }
  
  private calculateSkillOverlap(requiredSkills: string[], talentSkills: string[]): number {
    const intersection = requiredSkills.filter(skill => talentSkills.includes(skill));
    return intersection.length / requiredSkills.length;
  }
  
  private async fallbackIntentAnalysis(message: string): Promise<IntentAnalysis> {
    // AWS Comprehend を使用したフォールバック分析
    const sentimentResponse = await this.comprehendClient.detectSentiment({
      Text: message,
      LanguageCode: 'ja'
    }).promise();
    
    const entitiesResponse = await this.comprehendClient.detectEntities({
      Text: message,
      LanguageCode: 'ja'
    }).promise();
    
    // シンプルなキーワードベース分類
    const workKeywords = ['仕事', '職場', '上司', '同僚', '残業', '給料'];
    const lifeKeywords = ['住居', '買い物', '病院', '役所', '生活'];
    const legalKeywords = ['ビザ', '在留', '法律', '権利', '義務'];
    
    let category = 'life';
    if (workKeywords.some(keyword => message.includes(keyword))) {
      category = 'work';
    } else if (legalKeywords.some(keyword => message.includes(keyword))) {
      category = 'legal';
    }
    
    return {
      category,
      subcategory: 'general',
      intent: 'general_inquiry',
      urgency: sentimentResponse.Sentiment === 'NEGATIVE' ? 'medium' : 'low',
      confidence: 0.6,
      entities: entitiesResponse.Entities?.map(e => e.Text || '') || [],
      emotion: sentimentResponse.Sentiment?.toLowerCase() || 'neutral'
    };
  }
}
```

### **6.2 機械学習モデル管理**

```typescript
// MLモデルレジストリ
export class MLModelRegistry {
  private s3Client: AWS.S3;
  private sagemakerClient: AWS.SageMaker;
  private modelMetadataRepository: ModelMetadataRepository;
  
  constructor() {
    this.s3Client = new AWS.S3();
    this.sagemakerClient = new AWS.SageMaker();
    this.modelMetadataRepository = new ModelMetadataRepository();
  }
  
  async deployModel(modelConfig: ModelDeploymentConfig): Promise<ModelDeployment> {
    // モデルアーティファクトのS3アップロード
    const modelArtifactUri = await this.uploadModelArtifacts(modelConfig.modelPath, modelConfig.modelName);
    
    // SageMaker モデル作成
    const model = await this.sagemakerClient.createModel({
      ModelName: modelConfig.modelName,
      PrimaryContainer: {
        Image: modelConfig.containerImage,
        ModelDataUrl: modelArtifactUri,
        Environment: modelConfig.environment
      },
      ExecutionRoleArn: process.env.SAGEMAKER_EXECUTION_ROLE_ARN!
    }).promise();
    
    // エンドポイント設定作成
    const endpointConfig = await this.sagemakerClient.createEndpointConfig({
      EndpointConfigName: `${modelConfig.modelName}-config`,
      ProductionVariants: [{
        VariantName: 'primary',
        ModelName: modelConfig.modelName,
        InitialInstanceCount: modelConfig.instanceCount || 1,
        InstanceType: modelConfig.instanceType || 'ml.t2.medium',
        InitialVariantWeight: 1.0
      }]
    }).promise();
    
    // エンドポイント作成
    const endpoint = await this.sagemakerClient.createEndpoint({
      EndpointName: `${modelConfig.modelName}-endpoint`,
      EndpointConfigName: `${modelConfig.modelName}-config`
    }).promise();
    
    // メタデータ保存
    const modelMetadata = await this.modelMetadataRepository.create({
      modelName: modelConfig.modelName,
      modelType: modelConfig.modelType,
      version: modelConfig.version,
      endpointName: `${modelConfig.modelName}-endpoint`,
      s3ModelUri: modelArtifactUri,
      deployedAt: new Date(),
      status: 'deploying',
      metrics: modelConfig.metrics,
      description: modelConfig.description
    });
    
    // デプロイ完了待機（非同期）
    this.waitForEndpointInService(endpoint.EndpointArn!, modelMetadata.id);
    
    return {
      modelId: modelMetadata.id,
      endpointName: `${modelConfig.modelName}-endpoint`,
      status: 'deploying'
    };
  }
  
  async getActiveModel(modelType: string): Promise<ModelMetadata> {
    const activeModel = await this.modelMetadataRepository.findActiveByType(modelType);
    if (!activeModel) {
      throw new NotFoundError(`Active model for type ${modelType} not found`);
    }
    return activeModel;
  }
  
  async updateModel(modelType: string, newModelConfig: ModelDeploymentConfig): Promise<void> {
    // 新しいモデルをデプロイ
    const newDeployment = await this.deployModel(newModelConfig);
    
    // A/Bテスト用にトラフィックを段階的に切り替え
    await this.performCanaryDeployment(modelType, newDeployment.endpointName);
  }
  
  async performCanaryDeployment(modelType: string, newEndpointName: string): Promise<void> {
    const currentModel = await this.getActiveModel(modelType);
    
    // トラフィック分割設定
    const trafficSplits = [
      { current: 90, new: 10 },  // 10%のトラフィックを新モデルに
      { current: 70, new: 30 },  // 30%のトラフィックを新モデルに
      { current: 50, new: 50 },  // 50%のトラフィックを新モデルに
      { current: 0, new: 100 }   // 100%のトラフィックを新モデルに
    ];
    
    for (const split of trafficSplits) {
      // エンドポイント設定更新
      await this.sagemakerClient.updateEndpointWeightsAndCapacities({
        EndpointName: currentModel.endpointName,
        DesiredWeightsAndCapacities: [
          {
            VariantName: 'current',
            DesiredWeight: split.current
          },
          {
            VariantName: 'new',
            DesiredWeight: split.new
          }
        ]
      }).promise();
      
      // パフォーマンス監視
      await this.monitorModelPerformance(currentModel.endpointName, newEndpointName, 3600000); // 1時間
      
      // メトリクス評価
      const performanceComparison = await this.compareModelPerformance(currentModel.endpointName, newEndpointName);
      
      if (performanceComparison.newModelBetter) {
        console.log(`Canary deployment step ${split.new}% successful, continuing...`);
      } else {
        console.log('New model performance degraded, rolling back...');
        await this.rollbackDeployment(currentModel.endpointName);
        throw new Error('Canary deployment failed due to performance degradation');
      }
    }
    
    // デプロイ完了後、古いモデルを非アクティブ化
    await this.modelMetadataRepository.update(currentModel.id, { status: 'inactive' });
    await this.modelMetadataRepository.updateActiveModel(modelType, newEndpointName);
  }
  
  private async monitorModelPerformance(currentEndpoint: string, newEndpoint: string, durationMs: number): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(resolve, durationMs);
    });
  }
  
  private async compareModelPerformance(currentEndpoint: string, newEndpoint: string): Promise<{ newModelBetter: boolean }> {
    // CloudWatch メトリクスから比較データを取得
    const currentMetrics = await this.getEndpointMetrics(currentEndpoint);
    const newMetrics = await this.getEndpointMetrics(newEndpoint);
    
    const newModelBetter = 
      newMetrics.latency < currentMetrics.latency * 1.1 && // レイテンシが10%以内
      newMetrics.errorRate < currentMetrics.errorRate * 1.2; // エラー率が20%以内
    
    return { newModelBetter };
  }
}

// 機械学習パイプライン
export class MLPipeline {
  private dataProcessor: DataProcessor;
  private modelTrainer: ModelTrainer;
  private modelEvaluator: ModelEvaluator;
  private modelRegistry: MLModelRegistry;
  
  constructor() {
    this.dataProcessor = new DataProcessor();
    this.modelTrainer = new ModelTrainer();
    this.modelEvaluator = new ModelEvaluator();
    this.modelRegistry = new MLModelRegistry();
  }
  
  async runMatchingModelPipeline(): Promise<void> {
    console.log('Starting matching model training pipeline...');
    
    // 1. データ収集・前処理
    const rawData = await this.dataProcessor.collectMatchingData();
    const processedData = await this.dataProcessor.preprocessMatchingData(rawData);
    
    // 2. 特徴量エンジニアリング
    const features = await this.dataProcessor.engineerMatchingFeatures(processedData);
    
    // 3. データ分割
    const { trainData, validationData, testData } = await this.dataProcessor.splitData(features, {
      train: 0.7,
      validation: 0.15,
      test: 0.15
    });
    
    // 4. モデル訓練
    const trainedModel = await this.modelTrainer.trainMatchingModel(trainData, validationData);
    
    // 5. モデル評価
    const evaluation = await this.modelEvaluator.evaluateMatchingModel(trainedModel, testData);
    
    // 6. パフォーマンス閾値チェック
    if (evaluation.accuracy > 0.8 && evaluation.f1Score > 0.75) {
      // 7. モデルデプロイ
      await this.modelRegistry.deployModel({
        modelName: `matching-model-${Date.now()}`,
        modelType: 'matching_score',
        version: this.generateVersion(),
        modelPath: trainedModel.modelPath,
        containerImage: 'matching-model:latest',
        metrics: evaluation,
        description: 'Automated matching model training'
      });
      
      console.log('Matching model pipeline completed successfully');
    } else {
      console.log('Model performance below threshold, skipping deployment');
      throw new Error(`Model performance insufficient: accuracy=${evaluation.accuracy}, f1=${evaluation.f1Score}`);
    }
  }
  
  async runLearningPredictionPipeline(): Promise<void> {
    console.log('Starting learning prediction model training pipeline...');
    
    // 学習進捗データを使用した予測モデル訓練
    const learningData = await this.dataProcessor.collectLearningProgressData();
    const processedLearningData = await this.dataProcessor.preprocessLearningData(learningData);
    
    const { trainData, validationData, testData } = await this.dataProcessor.splitData(processedLearningData);
    
    const trainedModel = await this.modelTrainer.trainLearningPredictionModel(trainData, validationData);
    const evaluation = await this.modelEvaluator.evaluateLearningPredictionModel(trainedModel, testData);
    
    if (evaluation.rmse < 0.2 && evaluation.mape < 15) { // RMSE < 0.2, MAPE < 15%
      await this.modelRegistry.deployModel({
        modelName: `learning-prediction-${Date.now()}`,
        modelType: 'learning_prediction',
        version: this.generateVersion(),
        modelPath: trainedModel.modelPath,
        containerImage: 'learning-prediction:latest',
        metrics: evaluation,
        description: 'Learning outcome prediction model'
      });
    }
  }
  
  async runTurnoverPredictionPipeline(): Promise<void> {
    console.log('Starting turnover prediction model training pipeline...');
    
    // 従業員データ・相談履歴・勤務データを使用
    const employeeData = await this.dataProcessor.collectEmployeeData();
    const processedEmployeeData = await this.dataProcessor.preprocessEmployeeData(employeeData);
    
    const { trainData, validationData, testData } = await this.dataProcessor.splitData(processedEmployeeData);
    
    const trainedModel = await this.modelTrainer.trainTurnoverPredictionModel(trainData, validationData);
    const evaluation = await this.modelEvaluator.evaluateTurnoverPredictionModel(trainedModel, testData);
    
    if (evaluation.auc > 0.75 && evaluation.precision > 0.7) {
      await this.modelRegistry.deployModel({
        modelName: `turnover-prediction-${Date.now()}`,
        modelType: 'turnover_prediction',
        version: this.generateVersion(),
        modelPath: trainedModel.modelPath,
        containerImage: 'turnover-prediction:latest',
        metrics: evaluation,
        description: 'Employee turnover risk prediction model'
      });
    }
  }
  
  // 定期的なモデル再訓練スケジュール
  scheduleModelRetraining(): void {
    // 毎週日曜日 2:00 AM にマッチングモデル再訓練
    cron.schedule('0 2 * * 0', () => {
      this.runMatchingModelPipeline().catch(console.error);
    });
    
    // 毎月1日 3:00 AM に学習予測モデル再訓練
    cron.schedule('0 3 1 * *', () => {
      this.runLearningPredictionPipeline().catch(console.error);
    });
    
    // 毎四半期に離職予測モデル再訓練
    cron.schedule('0 4 1 */3 *', () => {
      this.runTurnoverPredictionPipeline().catch(console.error);
    });
  }
  
  private generateVersion(): string {
    const date = new Date();
    return `v${date.getFullYear()}.${date.getMonth() + 1}.${date.getDate()}`;
  }
}
```

---

## **7. セキュリティ設計**

### **7.1 セキュリティアーキテクチャ概要**

```typescript
// セキュリティ設定管理
export class SecurityConfig {
  static readonly SECURITY_HEADERS = {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': `
      default-src 'self';
      script-src 'self' 'unsafe-inline' https://apis.google.com;
      style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https:;
      connect-src 'self' wss: https:;
      media-src 'self' https:;
    `.replace(/\s+/g, ' ').trim(),
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Permissions-Policy': 'camera=(), microphone=(), geolocation=()'
  };
  
  static readonly RATE_LIMITS = {
    AUTH: { windowMs: 15 * 60 * 1000, max: 5 }, // 15分で5回
    API: { windowMs: 15 * 60 * 1000, max: 100 }, // 15分で100回
    UPLOAD: { windowMs: 60 * 60 * 1000, max: 10 }, // 1時間で10回
    CHAT: { windowMs: 60 * 1000, max: 30 } // 1分で30回
  };
  
  static readonly ENCRYPTION = {
    ALGORITHM: 'AES-256-GCM',
    KEY_DERIVATION: 'PBKDF2',
    ITERATIONS: 100000,
    SALT_LENGTH: 32,
    IV_LENGTH: 16,
    TAG_LENGTH: 16
  };
}

// セキュリティミドルウェア
export class SecurityMiddleware {
  // セキュリティヘッダー設定
  static securityHeaders() {
    return (req: Request, res: Response, next: NextFunction) => {
      Object.entries(SecurityConfig.SECURITY_HEADERS).forEach(([header, value]) => {
        res.setHeader(header, value);
      });
      next();
    };
  }
  
  // CORS設定
  static corsPolicy() {
    return cors({
      origin: (origin, callback) => {
        const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];
        
        if (!origin || allowedOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
      maxAge: 86400 // 24時間
    });
  }
  
  // 入力サニタイゼーション
  static inputSanitization() {
    return (req: Request, res: Response, next: NextFunction) => {
      // HTMLタグ除去
      const sanitizeValue = (value: any): any => {
        if (typeof value === 'string') {
          return validator.escape(value.trim());
        } else if (Array.isArray(value)) {
          return value.map(sanitizeValue);
        } else if (typeof value === 'object' && value !== null) {
          const sanitized: any = {};
          Object.keys(value).forEach(key => {
            sanitized[key] = sanitizeValue(value[key]);
          });
          return sanitized;
        }
        return value;
      };
      
      if (req.body) {
        req.body = sanitizeValue(req.body);
      }
      
      next();
    };
  }
  
  // SQLインジェクション防止
  static sqlInjectionProtection() {
    return (req: Request, res: Response, next: NextFunction) => {
      const checkSqlInjection = (value: string): boolean => {
        const sqlPatterns = [
          /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/i,
          /(;|\||\|\||&&|--|\/\*|\*\/)/,
          /('|('')|"|(\\")|(%27)|(%22))/
        ];
        
        return sqlPatterns.some(pattern => pattern.test(value));
      };
      
      const validateInput = (obj: any): void => {
        Object.values(obj).forEach(value => {
          if (typeof value === 'string' && checkSqlInjection(value)) {
            throw new ValidationError('Potential SQL injection detected');
          } else if (typeof value === 'object' && value !== null) {
            validateInput(value);
          }
        });
      };
      
      if (req.body) validateInput(req.body);
      if (req.query) validateInput(req.query);
      
      next();
    };
  }
}
```

### **7.2 認証・認可セキュリティ**

```typescript
// 高度認証サービス
export class AdvancedAuthService {
  private securityConfig: SecurityConfig;
  private auditLogger: AuditLogger;
  private riskAssessment: RiskAssessmentService;
  
  constructor() {
    this.securityConfig = new SecurityConfig();
    this.auditLogger = new AuditLogger();
    this.riskAssessment = new RiskAssessmentService();
  }
  
  // 多要素認証実装
  async setupMFA(userId: string, method: 'totp' | 'sms' | 'email'): Promise<MFASetupResponse> {
    const user = await userRepository.findById(userId);
    if (!user) {
      throw new NotFoundError('User not found');
    }
    
    switch (method) {
      case 'totp':
        return await this.setupTOTP(userId);
      case 'sms':
        return await this.setupSMS(userId, user.phoneNumber);
      case 'email':
        return await this.setupEmail(userId, user.email);
      default:
        throw new ValidationError('Invalid MFA method');
    }
  }
  
  private async setupTOTP(userId: string): Promise<MFASetupResponse> {
    const secret = authenticator.generateSecret();
    const qrCode = await qrcode.toDataURL(
      authenticator.keyuri(userId, 'DX Seed Platform', secret)
    );
    
    // 一時的にシークレットを保存（確認後に正式保存）
    await redis.setex(`mfa_setup:${userId}`, 300, secret); // 5分間有効
    
    return {
      secret,
      qrCode,
      backupCodes: this.generateBackupCodes()
    };
  }
  
  async verifyMFA(userId: string, code: string, method: string): Promise<boolean> {
    const user = await userRepository.findById(userId);
    if (!user || !user.mfaEnabled) {
      return false;
    }
    
    switch (method) {
      case 'totp':
        return this.verifyTOTP(user.mfaSecret, code);
      case 'sms':
        return await this.verifySMS(userId, code);
      case 'email':
        return await this.verifyEmail(userId, code);
      case 'backup':
        return await this.verifyBackupCode(userId, code);
      default:
        return false;
    }
  }
  
  // デバイストラッキング
  async trackDeviceLogin(userId: string, deviceInfo: DeviceInfo, ipAddress: string): Promise<DeviceVerification> {
    const deviceFingerprint = this.generateDeviceFingerprint(deviceInfo);
    
    // 既知のデバイスかチェック
    const knownDevice = await deviceRepository.findByUserAndFingerprint(userId, deviceFingerprint);
    
    if (knownDevice) {
      // 既知のデバイスからのアクセス
      await deviceRepository.updateLastSeen(knownDevice.id, ipAddress);
      return { verified: true, isNewDevice: false };
    }
    
    // 新しいデバイスからのアクセス
    const riskScore = await this.riskAssessment.assessDeviceRisk(userId, deviceInfo, ipAddress);
    
    if (riskScore > 70) {
      // 高リスク：デバイス認証を要求
      const verificationCode = this.generateVerificationCode();
      await this.sendDeviceVerificationEmail(userId, verificationCode, deviceInfo);
      
      await redis.setex(`device_verification:${userId}:${deviceFingerprint}`, 900, verificationCode); // 15分間有効
      
      return { verified: false, isNewDevice: true, requiresVerification: true };
    }
    
    // 中・低リスク：デバイスを登録
    await deviceRepository.create({
      userId,
      deviceFingerprint,
      deviceInfo,
      ipAddress,
      verified: true,
      firstSeen: new Date(),
      lastSeen: new Date()
    });
    
    return { verified: true, isNewDevice: true };
  }
  
  // セッション管理
  async manageSession(userId: string, sessionData: SessionData): Promise<void> {
    const sessionId = uuidv4();
    const sessionInfo = {
      userId,
      sessionId,
      ipAddress: sessionData.ipAddress,
      userAgent: sessionData.userAgent,
      createdAt: new Date(),
      lastActivity: new Date(),
      isActive: true
    };
    
    // セッション情報を保存
    await redis.setex(`session:${sessionId}`, 86400, JSON.stringify(sessionInfo)); // 24時間
    
    // ユーザーの他のセッションを確認（同時ログイン制限）
    const userSessions = await this.getUserActiveSessions(userId);
    if (userSessions.length >= 5) { // 最大5セッション
      // 最も古いセッションを無効化
      const oldestSession = userSessions.sort((a, b) => 
        new Date(a.lastActivity).getTime() - new Date(b.lastActivity).getTime()
      )[0];
      
      await this.invalidateSession(oldestSession.sessionId);
    }
    
    // 監査ログ
    await this.auditLogger.logSessionStart(userId, sessionId, sessionData);
  }
  
  private generateDeviceFingerprint(deviceInfo: DeviceInfo): string {
    const fingerprint = crypto
      .createHash('sha256')
      .update(`${deviceInfo.userAgent}${deviceInfo.screen}${deviceInfo.timezone}${deviceInfo.language}`)
      .digest('hex');
    
    return fingerprint;
  }
  
  private generateBackupCodes(): string[] {
    return Array.from({ length: 10 }, () => 
      crypto.randomBytes(4).toString('hex').toUpperCase()
    );
  }
}

// リスク評価サービス
export class RiskAssessmentService {
  async assessLoginRisk(userId: string, loginData: LoginData): Promise<RiskAssessment> {
    const factors = await Promise.all([
      this.checkLocationRisk(userId, loginData.ipAddress),
      this.checkTimeRisk(userId, loginData.timestamp),
      this.checkDeviceRisk(userId, loginData.deviceInfo),
      this.checkBehaviorRisk(userId, loginData),
      this.checkThreatIntelligence(loginData.ipAddress)
    ]);
    
    const totalRisk = factors.reduce((sum, factor) => sum + factor.score, 0) / factors.length;
    
    return {
      riskScore: totalRisk,
      riskLevel: this.getRiskLevel(totalRisk),
      factors: factors,
      recommendedActions: this.getRecommendedActions(totalRisk, factors)
    };
  }
  
  private async checkLocationRisk(userId: string, ipAddress: string): Promise<RiskFactor> {
    const location = await this.getLocationFromIP(ipAddress);
    const userLocations = await this.getUserHistoricalLocations(userId);
    
    const isNewLocation = !userLocations.some(loc => 
      this.calculateDistance(loc, location) < 100 // 100km以内
    );
    
    const isHighRiskCountry = this.HIGH_RISK_COUNTRIES.includes(location.country);
    
    let score = 0;
    if (isNewLocation) score += 30;
    if (isHighRiskCountry) score += 40;
    
    return {
      type: 'location',
      score: Math.min(score, 100),
      details: { location, isNewLocation, isHighRiskCountry }
    };
  }
  
  private async checkBehaviorRisk(userId: string, loginData: LoginData): Promise<RiskFactor> {
    const recentAttempts = await this.getRecentLoginAttempts(userId, 3600000); // 1時間以内
    const failedAttempts = recentAttempts.filter(attempt => !attempt.successful).length;
    
    let score = 0;
    if (failedAttempts > 3) score += 50;
    if (failedAttempts > 5) score += 30;
    
    return {
      type: 'behavior',
      score: Math.min(score, 100),
      details: { failedAttempts, recentAttempts: recentAttempts.length }
    };
  }
  
  private readonly HIGH_RISK_COUNTRIES = ['CN', 'RU', 'KP', 'IR']; // 例
}
```

### **7.3 データ保護・暗号化**

```typescript
// 暗号化サービス
export class EncryptionService {
  private readonly masterKey: Buffer;
  private readonly algorithm = 'aes-256-gcm';
  
  constructor() {
    this.masterKey = Buffer.from(process.env.MASTER_ENCRYPTION_KEY!, 'hex');
  }
  
  // 機密データ暗号化
  async encryptSensitiveData(data: string, context?: string): Promise<EncryptedData> {
    const salt = crypto.randomBytes(32);
    const iv = crypto.randomBytes(16);
    
    // キー導出
    const key = crypto.pbkdf2Sync(this.masterKey, salt, 100000, 32, 'sha256');
    
    // 暗号化
    const cipher = crypto.createCipher(this.algorithm, key);
    cipher.setAAD(Buffer.from(context || '', 'utf8'));
    
    const encrypted = Buffer.concat([
      cipher.update(data, 'utf8'),
      cipher.final()
    ]);
    
    const tag = cipher.getAuthTag();
    
    return {
      encrypted: encrypted.toString('base64'),
      salt: salt.toString('base64'),
      iv: iv.toString('base64'),
      tag: tag.toString('base64'),
      algorithm: this.algorithm
    };
  }
  
  // 機密データ復号化
  async decryptSensitiveData(encryptedData: EncryptedData, context?: string): Promise<string> {
    const salt = Buffer.from(encryptedData.salt, 'base64');
    const iv = Buffer.from(encryptedData.iv, 'base64');
    const tag = Buffer.from(encryptedData.tag, 'base64');
    const encrypted = Buffer.from(encryptedData.encrypted, 'base64');
    
    // キー導出
    const key = crypto.pbkdf2Sync(this.masterKey, salt, 100000, 32, 'sha256');
    
    // 復号化
    const decipher = crypto.createDecipher(this.algorithm, key);
    decipher.setAuthTag(tag);
    decipher.setAAD(Buffer.from(context || '', 'utf8'));
    
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);
    
    return decrypted.toString('utf8');
  }
  
  // パスワードハッシュ化
  async hashPassword(password: string): Promise<string> {
    const salt = await bcrypt.genSalt(12);
    return bcrypt.hash(password, salt);
  }
  
  // パスワード検証
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
  
  // フィールドレベル暗号化（データベース用）
  async encryptField(value: string, fieldType: string): Promise<string> {
    const context = `field:${fieldType}`;
    const encrypted = await this.encryptSensitiveData(value, context);
    return JSON.stringify(encrypted);
  }
  
  async decryptField(encryptedValue: string, fieldType: string): Promise<string> {
    const context = `field:${fieldType}`;
    const encrypted = JSON.parse(encryptedValue);
    return this.decryptSensitiveData(encrypted, context);
  }
}

// データマスキング
export class DataMaskingService {
  // 個人情報マスキング
  maskPersonalData(data: any, userRole: string): any {
    const maskingRules = this.getMaskingRules(userRole);
    
    return this.applyMaskingRules(data, maskingRules);
  }
  
  private getMaskingRules(userRole: string): MaskingRules {
    const rules: Record<string, MaskingRules> = {
      company_admin: {
        email: (email: string) => this.maskEmail(email),
        phone: (phone: string) => this.maskPhone(phone),
        passportNumber: () => '***MASKED***',
        personalAddress: (addr: any) => ({ ...addr, street: '***MASKED***' })
      },
      admin: {
        // 管理者は制限なし
      },
      support_staff: {
        email: (email: string) => this.maskEmail(email),
        passportNumber: () => '***MASKED***',
        personalAddress: (addr: any) => ({ 
          ...addr, 
          street: '***MASKED***',
          postalCode: '***MASKED***'
        })
      }
    };
    
    return rules[userRole] || rules.company_admin;
  }
  
  private maskEmail(email: string): string {
    const [username, domain] = email.split('@');
    const maskedUsername = username.substring(0, 2) + '*'.repeat(username.length - 2);
    return `${maskedUsername}@${domain}`;
  }
  
  private maskPhone(phone: string): string {
    if (phone.length <= 4) return phone;
    return phone.substring(0, 3) + '*'.repeat(phone.length - 6) + phone.substring(phone.length - 3);
  }
  
  private applyMaskingRules(data: any, rules: MaskingRules): any {
    if (Array.isArray(data)) {
      return data.map(item => this.applyMaskingRules(item, rules));
    }
    
    if (typeof data !== 'object' || data === null) {
      return data;
    }
    
    const masked: any = {};
    
    Object.keys(data).forEach(key => {
      if (rules[key]) {
        masked[key] = rules[key](data[key]);
      } else if (typeof data[key] === 'object') {
        masked[key] = this.applyMaskingRules(data[key], rules);
      } else {
        masked[key] = data[key];
      }
    });
    
    return masked;
  }
}

// セキュアファイルアップロード
export class SecureFileUploadService {
  private readonly allowedMimeTypes = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  ];
  
  private readonly maxFileSize = 10 * 1024 * 1024; // 10MB
  
  async validateAndUploadFile(file: Express.Multer.File, userId: string): Promise<FileUploadResult> {
    // ファイル検証
    await this.validateFile(file);
    
    // ウイルススキャン
    await this.scanForMalware(file);
    
    // ファイル名サニタイゼーション
    const sanitizedFileName = this.sanitizeFileName(file.originalname);
    
    // 一意なファイル名生成
    const uniqueFileName = `${uuidv4()}-${sanitizedFileName}`;
    
    // S3アップロード（暗号化）
    const uploadResult = await this.uploadToS3(file.buffer, uniqueFileName, {
      ContentType: file.mimetype,
      Metadata: {
        uploadedBy: userId,
        originalName: file.originalname,
        uploadDate: new Date().toISOString()
      },
      ServerSideEncryption: 'AES256'
    });
    
    // ファイルメタデータ保存
    const fileRecord = await fileRepository.create({
      fileName: uniqueFileName,
      originalName: file.originalname,
      mimeType: file.mimetype,
      fileSize: file.size,
      s3Key: uploadResult.Key,
      uploadedBy: userId,
      virus_scanned: true,
      uploadedAt: new Date()
    });
    
    return {
      fileId: fileRecord.id,
      fileName: uniqueFileName,
      url: uploadResult.Location,
      size: file.size
    };
  }
  
  private async validateFile(file: Express.Multer.File): Promise<void> {
    // ファイルサイズチェック
    if (file.size > this.maxFileSize) {
      throw new ValidationError('File size exceeds maximum allowed size');
    }
    
    // MIMEタイプチェック
    if (!this.allowedMimeTypes.includes(file.mimetype)) {
      throw new ValidationError('File type not allowed');
    }
    
    // ファイルヘッダー検証（MIME type spoofing 防止）
    const actualMimeType = await this.detectMimeTypeFromBuffer(file.buffer);
    if (actualMimeType !== file.mimetype) {
      throw new ValidationError('File content does not match declared MIME type');
    }
  }
  
  private async scanForMalware(file: Express.Multer.File): Promise<void> {
    // ClamAV等のウイルススキャンサービスとの連携
    const scanResult = await clamAV.scanBuffer(file.buffer);
    
    if (scanResult.isInfected) {
      throw new ValidationError('File contains malware');
    }
  }
  
  private sanitizeFileName(fileName: string): string {
    // 危険な文字を除去
    return fileName
      .replace(/[^a-zA-Z0-9.\-_]/g, '_')
      .replace(/\.{2,}/g, '.')
      .substring(0, 100); // 長さ制限
  }
}
```

---

## **8. インフラ・デプロイ設計**

### **8.1 AWS インフラストラクチャ**

```yaml
# Terraform設定例
# infrastructure/main.tf

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  
  backend "s3" {
    bucket = "dx-seed-terraform-state"
    key    = "infrastructure/terraform.tfstate"
    region = "ap-northeast-1"
    encrypt = true
    dynamodb_table = "terraform-lock"
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = {
      Environment = var.environment
      Project     = "dx-seed"
      ManagedBy   = "terraform"
    }
  }
}

# VPC設定
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name = "${var.project_name}-vpc-${var.environment}"
  }
}

# パブリックサブネット
resource "aws_subnet" "public" {
  count = length(var.availability_zones)
  
  vpc_id            = aws_vpc.main.id
  cidr_block        = var.public_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  
  map_public_ip_on_launch = true
  
  tags = {
    Name = "${var.project_name}-public-subnet-${count.index + 1}-${var.environment}"
    Type = "public"
  }
}

# プライベートサブネット
resource "aws_subnet" "private" {
  count = length(var.availability_zones)
  
  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  
  tags = {
    Name = "${var.project_name}-private-subnet-${count.index + 1}-${var.environment}"
    Type = "private"
  }
}

# EKSクラスター
resource "aws_eks_cluster" "main" {
  name     = "${var.project_name}-cluster-${var.environment}"
  role_arn = aws_iam_role.eks_cluster.arn
  version  = var.kubernetes_version
  
  vpc_config {
    subnet_ids              = concat(aws_subnet.public[*].id, aws_subnet.private[*].id)
    endpoint_private_access = true
    endpoint_public_access  = true
    public_access_cidrs     = var.public_access_cidrs
  }
  
  encryption_config {
    provider {
      key_arn = aws_kms_key.eks.arn
    }
    resources = ["secrets"]
  }
  
  enabled_cluster_log_types = ["api", "audit", "authenticator", "controllerManager", "scheduler"]
  
  depends_on = [
    aws_iam_role_policy_attachment.eks_cluster_policy,
    aws_iam_role_policy_attachment.eks_vpc_resource_controller,
  ]
  
  tags = {
    Name = "${var.project_name}-eks-cluster-${var.environment}"
  }
}

# EKSノードグループ
resource "aws_eks_node_group" "main" {
  cluster_name    = aws_eks_cluster.main.name
  node_group_name = "${var.project_name}-nodes-${var.environment}"
  node_role_arn   = aws_iam_role.eks_node_group.arn
  subnet_ids      = aws_subnet.private[*].id
  
  instance_types = var.node_instance_types
  ami_type       = "AL2_x86_64"
  capacity_type  = "ON_DEMAND"
  disk_size      = 50
  
  scaling_config {
    desired_size = var.node_desired_size
    max_size     = var.node_max_size
    min_size     = var.node_min_size
  }
  
  update_config {
    max_unavailable = 1
  }
  
  remote_access {
    ec2_ssh_key = var.ssh_key_name
    source_security_group_ids = [aws_security_group.eks_remote_access.id]
  }
  
  depends_on = [
    aws_iam_role_policy_attachment.eks_worker_node_policy,
    aws_iam_role_policy_attachment.eks_cni_policy,
    aws_iam_role_policy_attachment.eks_container_registry_policy,
  ]
  
  tags = {
    Name = "${var.project_name}-eks-nodes-${var.environment}"
  }
}

# RDSクラスター（PostgreSQL）
resource "aws_rds_cluster" "main" {
  cluster_identifier     = "${var.project_name}-cluster-${var.environment}"
  engine                = "aurora-postgresql"
  engine_version        = var.postgres_version
  database_name         = var.database_name
  master_username       = var.database_username
  master_password       = var.database_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  backup_retention_period = var.backup_retention_period
  preferred_backup_window = "03:00-04:00"
  preferred_maintenance_window = "sun:04:00-sun:05:00"
  
  storage_encrypted = true
  kms_key_id       = aws_kms_key.rds.arn
  
  skip_final_snapshot = var.environment == "dev"
  final_snapshot_identifier = var.environment != "dev" ? "${var.project_name}-final-snapshot-${var.environment}-${formatdate("YYYY-MM-DD-hhmm", timestamp())}" : null
  
  enabled_cloudwatch_logs_exports = ["postgresql"]
  
  tags = {
    Name = "${var.project_name}-rds-cluster-${var.environment}"
  }
}

# RDSインスタンス
resource "aws_rds_cluster_instance" "main" {
  count              = var.rds_instance_count
  identifier         = "${var.project_name}-instance-${count.index + 1}-${var.environment}"
  cluster_identifier = aws_rds_cluster.main.id
  instance_class     = var.rds_instance_class
  engine             = aws_rds_cluster.main.engine
  engine_version     = aws_rds_cluster.main.engine_version
  
  performance_insights_enabled = true
  monitoring_interval          = 60
  monitoring_role_arn         = aws_iam_role.rds_monitoring.arn
  
  tags = {
    Name = "${var.project_name}-rds-instance-${count.index + 1}-${var.environment}"
  }
}

# ElastiCache（Redis）
resource "aws_elasticache_replication_group" "main" {
  replication_group_id      = "${var.project_name}-redis-${var.environment}"
  description              = "Redis cluster for ${var.project_name} ${var.environment}"
  
  node_type               = var.redis_node_type
  port                    = 6379
  parameter_group_name    = "default.redis7"
  
  num_cache_clusters      = var.redis_num_replicas
  
  subnet_group_name       = aws_elasticache_subnet_group.main.name
  security_group_ids      = [aws_security_group.redis.id]
  
  at_rest_encryption_enabled = true
  transit_encryption_enabled = true
  auth_token                 = var.redis_auth_token
  
  snapshot_retention_limit = 7
  snapshot_window         = "03:00-05:00"
  maintenance_window      = "sun:05:00-sun:07:00"
  
  log_delivery_configuration {
    destination      = aws_cloudwatch_log_group.redis_slow.name
    destination_type = "cloudwatch-logs"
    log_format      = "text"
    log_type        = "slow-log"
  }
  
  tags = {
    Name = "${var.project_name}-redis-${var.environment}"
  }
}

# Elasticsearch/OpenSearch
resource "aws_opensearch_domain" "main" {
  domain_name    = "${var.project_name}-search-${var.environment}"
  engine_version = "OpenSearch_2.3"
  
  cluster_config {
    instance_type            = var.opensearch_instance_type
    instance_count          = var.opensearch_instance_count
    dedicated_master_enabled = var.opensearch_instance_count > 2
    master_instance_type    = var.opensearch_instance_count > 2 ? "t3.small.search" : null
    master_instance_count   = var.opensearch_instance_count > 2 ? 3 : null
    zone_awareness_enabled  = var.opensearch_instance_count > 1
    
    zone_awareness_config {
      availability_zone_count = var.opensearch_instance_count > 1 ? 2 : 1
    }
  }
  
  vpc_options {
    security_group_ids = [aws_security_group.opensearch.id]
    subnet_ids        = slice(aws_subnet.private[*].id, 0, min(2, length(aws_subnet.private)))
  }
  
  ebs_options {
    ebs_enabled = true
    volume_type = "gp3"
    volume_size = var.opensearch_volume_size
  }
  
  encrypt_at_rest {
    enabled    = true
    kms_key_id = aws_kms_key.opensearch.arn
  }
  
  node_to_node_encryption {
    enabled = true
  }
  
  domain_endpoint_options {
    enforce_https       = true
    tls_security_policy = "Policy-Min-TLS-1-2-2019-07"
  }
  
  advanced_security_options {
    enabled                        = true
    anonymous_auth_enabled         = false
    internal_user_database_enabled = true
    master_user_options {
      master_user_name     = var.opensearch_master_user
      master_user_password = var.opensearch_master_password
    }
  }
  
  log_publishing_options {
    cloudwatch_log_group_arn = "${aws_cloudwatch_log_group.opensearch.arn}:*"
    log_type                = "INDEX_SLOW_LOGS"
  }
  
  tags = {
    Name = "${var.project_name}-opensearch-${var.environment}"
  }
}
```

### **8.2 Kubernetes設定**

```yaml
# kubernetes/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dx-seed-production
  labels:
    name: dx-seed-production
---
# kubernetes/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: dx-seed-config
  namespace: dx-seed-production
data:
  NODE_ENV: "production"
  LOG_LEVEL: "info"
  API_BASE_URL: "https://api.dx-seed.com"
  FRONTEND_URL: "https://app.dx-seed.com"
  REDIS_HOST: "dx-seed-redis-cluster.cache.amazonaws.com"
  POSTGRES_HOST: "dx-seed-cluster.cluster-xyz.ap-northeast-1.rds.amazonaws.com"
  OPENSEARCH_HOST: "search-dx-seed-search-production-xyz.ap-northeast-1.es.amazonaws.com"
---
# kubernetes/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: dx-seed-secrets
  namespace: dx-seed-production
type: Opaque
data:
  POSTGRES_PASSWORD: <base64-encoded-password>
  REDIS_AUTH_TOKEN: <base64-encoded-token>
  JWT_SECRET: <base64-encoded-secret>
  OPENAI_API_KEY: <base64-encoded-key>
  AWS_ACCESS_KEY_ID: <base64-encoded-key>
  AWS_SECRET_ACCESS_KEY: <base64-encoded-secret>
---
# kubernetes/auth-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: dx-seed-production
  labels:
    app: auth-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: auth-service
  template:
    metadata:
      labels:
        app: auth-service
    spec:
      containers:
      - name: auth-service
        image: dx-seed/auth-service:latest
        ports:
        - containerPort: 3001
        envFrom:
        - configMapRef:
            name: dx-seed-config
        - secretRef:
            name: dx-seed-secrets
        env:
        - name: SERVICE_NAME
          value: "auth-service"
        - name: PORT
          value: "3001"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
        volumeMounts:
        - name: tmp-volume
          mountPath: /tmp
        - name: logs-volume
          mountPath: /app/logs
      volumes:
      - name: tmp-volume
        emptyDir: {}
      - name: logs-volume
        emptyDir: {}
      imagePullSecrets:
      - name: registry-secret
---
apiVersion: v1
kind: Service
metadata:
  name: auth-service
  namespace: dx-seed-production
  labels:
    app: auth-service
spec:
  selector:
    app: auth-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3001
  type: ClusterIP
---
# kubernetes/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: dx-seed-ingress
  namespace: dx-seed-production
  annotations:
    kubernetes.io/ingress.class: "alb"
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/ssl-redirect: '443'
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:ap-northeast-1:123456789012:certificate/xyz
    alb.ingress.kubernetes.io/security-groups: sg-123456789
    alb.ingress.kubernetes.io/subnets: subnet-12345,subnet-67890
    alb.ingress.kubernetes.io/tags: Environment=production,Project=dx-seed
spec:
  rules:
  - host: api.dx-seed.com
    http:
      paths:
      - path: /v1/auth
        pathType: Prefix
        backend:
          service:
            name: auth-service
            port:
              number: 80
      - path: /v1/users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
      - path: /v1/lms
        pathType: Prefix
        backend:
          service:
            name: lms-service
            port:
              number: 80
      - path: /v1/matching
        pathType: Prefix
        backend:
          service:
            name: matching-service
            port:
              number: 80
      - path: /v1/employment
        pathType: Prefix
        backend:
          service:
            name: employment-service
            port:
              number: 80
      - path: /v1/support
        pathType: Prefix
        backend:
          service:
            name: support-service
            port:
              number: 80
      - path: /v1/translation
        pathType: Prefix
        backend:
          service:
            name: translation-service
            port:
              number: 80
---
# kubernetes/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: auth-service-hpa
  namespace: dx-seed-production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: auth-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Pods
        value: 1
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Pods
        value: 2
        periodSeconds: 60
```

### **8.3 CI/CD パイプライン**

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  AWS_REGION: ap-northeast-1
  ECR_REGISTRY: 123456789012.dkr.ecr.ap-northeast-1.amazonaws.com
  EKS_CLUSTER_NAME: dx-seed-cluster-production

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_USER: test
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        npm ci
        npm run build
    
    - name: Run linting
      run: npm run lint
    
    - name: Run type checking
      run: npm run type-check
    
    - name: Run unit tests
      run: npm run test:unit
      env:
        NODE_ENV: test
        DATABASE_URL: postgresql://test:test@localhost:5432/test
        REDIS_URL: redis://localhost:6379
    
    - name: Run integration tests
      run: npm run test:integration
      env:
        NODE_ENV: test
        DATABASE_URL: postgresql://test:test@localhost:5432/test
        REDIS_URL: redis://localhost:6379
    
    - name: Generate test coverage report
      run: npm run test:coverage
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Snyk security scan
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build-and-push:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    strategy:
      matrix:
        service: 
          - auth-service
          - user-service
          - lms-service
          - matching-service
          - employment-service
          - support-service
          - translation-service
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build Docker image
      run: |
        docker build \
          --target production \
          --build-arg SERVICE_NAME=${{ matrix.service }} \
          -t ${{ env.ECR_REGISTRY }}/${{ matrix.service }}:${{ github.sha }} \
          -t ${{ env.ECR_REGISTRY }}/${{ matrix.service }}:latest \
          .
    
    - name: Scan Docker image
      run: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image \
          --exit-code 1 \
          --severity HIGH,CRITICAL \
          ${{ env.ECR_REGISTRY }}/${{ matrix.service }}:${{ github.sha }}
    
    - name: Push Docker image
      run: |
        docker push ${{ env.ECR_REGISTRY }}/${{ matrix.service }}:${{ github.sha }}
        docker push ${{ env.ECR_REGISTRY }}/${{ matrix.service }}:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig \
          --region ${{ env.AWS_REGION }} \
          --name ${{ env.EKS_CLUSTER_NAME }}
    
    - name: Deploy to Kubernetes
      run: |
        # Update image tags in deployment files
        find kubernetes/ -name "*.yaml" -exec sed -i 's|:latest|:${{ github.sha }}|g' {} \;
        
        # Apply configurations
        kubectl apply -f kubernetes/namespace.yaml
        kubectl apply -f kubernetes/configmap.yaml
        kubectl apply -f kubernetes/secret.yaml
        kubectl apply -f kubernetes/
        
        # Wait for rollout
        kubectl rollout status deployment/auth-service -n dx-seed-production --timeout=300s
        kubectl rollout status deployment/user-service -n dx-seed-production --timeout=300s
        kubectl rollout status deployment/lms-service -n dx-seed-production --timeout=300s
        kubectl rollout status deployment/matching-service -n dx-seed-production --timeout=300s
        kubectl rollout status deployment/employment-service -n dx-seed-production --timeout=300s
        kubectl rollout status deployment/support-service -n dx-seed-production --timeout=300s
        kubectl rollout status deployment/translation-service -n dx-seed-production --timeout=300s
    
    - name: Run smoke tests
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Get ALB URL
        ALB_URL=$(kubectl get ingress dx-seed-ingress -n dx-seed-production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Run smoke tests
        curl -f https://$ALB_URL/v1/auth/health || exit 1
        curl -f https://$ALB_URL/v1/users/health || exit 1
        curl -f https://$ALB_URL/v1/lms/health || exit 1
    
    - name: Notify deployment success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: ':rocket: Deployment to production completed successfully!'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
    
    - name: Notify deployment failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: ':x: Deployment to production failed!'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### **8.4 Docker設定**

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Security: Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Install dependencies
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Build stage
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build specific service
ARG SERVICE_NAME
ENV SERVICE_NAME=${SERVICE_NAME}

RUN npm run build:${SERVICE_NAME}

# Production stage
FROM base AS production
WORKDIR /app

# Copy built application
ARG SERVICE_NAME
COPY --from=builder /app/dist/${SERVICE_NAME} ./
COPY --from=deps /app/node_modules ./node_modules

# Security: Switch to non-root user
USER nextjs

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:${PORT:-3000}/health || exit 1

# Expose port
EXPOSE 3000

# Start application
CMD ["node", "index.js"]
```

---

## **9. 外部システム連携設計**

### **9.1 決済システム連携**

```typescript
// 決済サービス統合
export class PaymentGatewayService {
  private stripeClient: Stripe;
  private paypalClient: PayPal;
  
  constructor() {
    this.stripeClient = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2023-10-16'
    });
    this.paypalClient = new PayPal({
      clientId: process.env.PAYPAL_CLIENT_ID!,
      clientSecret: process.env.PAYPAL_CLIENT_SECRET!,
      environment: process.env.NODE_ENV === 'production' ? 'live' : 'sandbox'
    });
  }
  
  // Stripe決済処理
  async processStripePayment(paymentData: StripePaymentData): Promise<PaymentResult> {
    try {
      // Payment Intent作成
      const paymentIntent = await this.stripeClient.paymentIntents.create({
        amount: Math.round(paymentData.amount * 100), // 円を銭に変換
        currency: paymentData.currency || 'jpy',
        payment_method: paymentData.paymentMethodId,
        customer: paymentData.customerId,
        description: paymentData.description,
        metadata: {
          orderId: paymentData.orderId,
          userId: paymentData.userId,
          serviceType: paymentData.serviceType
        },
        confirm: true,
        return_url: `${process.env.FRONTEND_URL}/payment/success`
      });
      
      return {
        success: true,
        transactionId: paymentIntent.id,
        status: paymentIntent.status,
        amount: paymentData.amount,
        currency: paymentData.currency || 'jpy'
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        code: error.code
      };
    }
  }
  
  // PayPal決済処理
  async processPayPalPayment(paymentData: PayPalPaymentData): Promise<PaymentResult> {
    try {
      const request = new paypal.orders.OrdersCreateRequest();
      request.prefer("return=representation");
      request.requestBody({
        intent: 'CAPTURE',
        purchase_units: [{
          amount: {
            currency_code: paymentData.currency || 'JPY',
            value: paymentData.amount.toString()
          },
          description: paymentData.description,
          custom_id: paymentData.orderId
        }],
        application_context: {
          return_url: `${process.env.FRONTEND_URL}/payment/paypal/success`,
          cancel_url: `${process.env.FRONTEND_URL}/payment/paypal/cancel`
        }
      });
      
      const order = await this.paypalClient.execute(request);
      
      return {
        success: true,
        transactionId: order.result.id,
        status: order.result.status,
        amount: paymentData.amount,
        currency: paymentData.currency || 'JPY',
        approvalUrl: order.result.links.find((link: any) => link.rel === 'approve')?.href
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  // 国際送金（Wise API）
  async processInternationalTransfer(transferData: InternationalTransferData): Promise<TransferResult> {
    const wiseClient = axios.create({
      baseURL: 'https://api.transferwise.com',
      headers: {
        'Authorization': `Bearer ${process.env.WISE_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    try {
      // 受取人作成
      const recipient = await wiseClient.post('/v1/accounts', {
        currency: transferData.targetCurrency,
        type: transferData.accountType,
        profile: transferData.profileId,
        accountHolderName: transferData.recipientName,
        details: transferData.accountDetails
      });
      
      // 見積もり作成
      const quote = await wiseClient.post('/v2/quotes', {
        sourceCurrency: transferData.sourceCurrency,
        targetCurrency: transferData.targetCurrency,
        sourceAmount: transferData.amount,
        profile: transferData.profileId
      });
      
      // 送金作成
      const transfer = await wiseClient.post('/v1/transfers', {
        targetAccount: recipient.data.id,
        quoteUuid: quote.data.id,
        customerTransactionId: transferData.orderId,
        details: {
          reference: transferData.reference || 'DX Seed Platform Payment'
        }
      });
      
      // 送金実行
      const funding = await wiseClient.post(`/v3/transfers/${transfer.data.id}/payments`, {
        type: 'BALANCE'
      });
      
      return {
        success: true,
        transferId: transfer.data.id,
        status: transfer.data.status,
        fee: quote.data.fee,
        exchangeRate: quote.data.rate,
        estimatedDelivery: quote.data.deliveryEstimate
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.response?.data?.message || error.message
      };
    }
  }
}
```

### **9.2 政府API連携**

```typescript
// 政府システム連携サービス
export class GovernmentAPIService {
  private immigrationAPIClient: AxiosInstance;
  private laborAPIClient: AxiosInstance;
  
  constructor() {
    this.immigrationAPIClient = axios.create({
      baseURL: process.env.IMMIGRATION_API_BASE_URL,
      headers: {
        'Authorization': `Bearer ${process.env.IMMIGRATION_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    this.laborAPIClient = axios.create({
      baseURL: process.env.LABOR_API_BASE_URL,
      headers: {
        'Authorization': `Bearer ${process.env.LABOR_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
  }
  
  // 在留資格申請状況確認
  async checkVisaApplicationStatus(applicationNumber: string): Promise<VisaApplicationStatus> {
    try {
      const response = await this.immigrationAPIClient.get(`/applications/${applicationNumber}/status`);
      
      return {
        applicationNumber,
        status: response.data.status,
        currentStage: response.data.currentStage,
        estimatedCompletion: response.data.estimatedCompletion,
        requiredDocuments: response.data.requiredDocuments,
        lastUpdated: response.data.lastUpdated
      };
    } catch (error: any) {
      if (error.response?.status === 404) {
        throw new NotFoundError('Application not found');
      }
      throw new AppError('Failed to check visa status', 500, 'GOVERNMENT_API_ERROR');
    }
  }
  
  // 在留資格申請提出
  async submitVisaApplication(applicationData: VisaApplicationSubmission): Promise<SubmissionResult> {
    try {
      // 書類検証
      await this.validateDocuments(applicationData.documents);
      
      // 申請提出
      const response = await this.immigrationAPIClient.post('/applications', {
        applicationType: applicationData.type,
        applicantInfo: applicationData.applicant,
        employerInfo: applicationData.employer,
        documents: applicationData.documents,
        supportingInfo: applicationData.supportingInfo
      });
      
      return {
        success: true,
        applicationNumber: response.data.applicationNumber,
        submissionDate: response.data.submissionDate,
        estimatedProcessingTime: response.data.estimatedProcessingTime
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.response?.data?.message || error.message,
        validationErrors: error.response?.data?.validationErrors
      };
    }
  }
  
  // 労働基準監督署への報告
  async submitLaborReport(reportData: LaborReport): Promise<ReportSubmissionResult> {
    try {
      const response = await this.laborAPIClient.post('/reports/foreign-workers', {
        reportingPeriod: reportData.period,
        companyInfo: reportData.company,
        employees: reportData.employees.map(emp => ({
          employeeId: emp.id,
          nationality: emp.nationality,
          visaType: emp.visaType,
          workHours: emp.workHours,
          salary: emp.salary,
          supportProvided: emp.supportProvided
        })),
        complianceStatus: reportData.complianceStatus
      });
      
      return {
        success: true,
        reportId: response.data.reportId,
        submissionDate: response.data.submissionDate,
        nextReportDue: response.data.nextReportDue
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.response?.data?.message || error.message
      };
    }
  }
  
  // e-Gov API連携（行政手続きオンライン）
  async checkAdministrativeProcedureStatus(procedureId: string): Promise<ProcedureStatus> {
    const egovClient = axios.create({
      baseURL: 'https://api.e-gov.go.jp/v1',
      headers: {
        'Authorization': `Bearer ${process.env.EGOV_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    try {
      const response = await egovClient.get(`/procedures/${procedureId}/status`);
      
      return {
        procedureId,
        status: response.data.status,
        progress: response.data.progress,
        estimatedCompletion: response.data.estimatedCompletion,
        requiredActions: response.data.requiredActions
      };
    } catch (error: any) {
      throw new AppError('Failed to check procedure status', 500, 'EGOV_API_ERROR');
    }
  }
  
  private async validateDocuments(documents: Document[]): Promise<void> {
    for (const doc of documents) {
      // 書類形式チェック
      if (!this.isValidDocumentFormat(doc)) {
        throw new ValidationError(`Invalid document format: ${doc.name}`);
      }
      
      // 電子署名検証
      if (doc.digitalSignature) {
        const isValidSignature = await this.verifyDigitalSignature(doc);
        if (!isValidSignature) {
          throw new ValidationError(`Invalid digital signature: ${doc.name}`);
        }
      }
    }
  }
  
  private isValidDocumentFormat(document: Document): boolean {
    const allowedFormats = ['pdf', 'jpg', 'png'];
    const fileExtension = document.name.split('.').pop()?.toLowerCase();
    return allowedFormats.includes(fileExtension || '');
  }
  
  private async verifyDigitalSignature(document: Document): Promise<boolean> {
    // デジタル署名検証ロジック
    // 実際の実装では、証明書検証ライブラリを使用
    return true; // 簡略化
  }
}
```

### **9.3 外部教育機関連携**

```typescript
// 教育機関連携サービス
export class EducationalInstitutionService {
  private ltiProvider: LTIProvider;
  private ssoProvider: SSOProvider;
  
  constructor() {
    this.ltiProvider = new LTIProvider();
    this.ssoProvider = new SSOProvider();
  }
  
  // LTI（Learning Tools Interoperability）連携
  async initiateLTISession(institutionId: string, userId: string, courseId: string): Promise<LTISession> {
    const institution = await institutionRepository.findById(institutionId);
    if (!institution) {
      throw new NotFoundError('Institution not found');
    }
    
    // LTI Launch Request作成
    const ltiParams = {
      lti_version: 'LTI-1p0',
      lti_message_type: 'basic-lti-launch-request',
      resource_link_id: courseId,
      user_id: userId,
      lis_person_name_full: await this.getUserFullName(userId),
      lis_person_contact_email_primary: await this.getUserEmail(userId),
      context_id: institutionId,
      launch_presentation_return_url: `${process.env.FRONTEND_URL}/lti/return`,
      tool_consumer_instance_guid: process.env.LTI_CONSUMER_GUID,
      custom_institution_id: institutionId
    };
    
    // OAuth署名生成
    const signature = this.ltiProvider.generateSignature(
      institution.ltiEndpoint,
      'POST',
      ltiParams,
      institution.ltiConsumerSecret
    );
    
    return {
      launchUrl: institution.ltiEndpoint,
      parameters: { ...ltiParams, oauth_signature: signature },
      sessionId: uuidv4()
    };
  }
  
  // SSO連携（SAML/OAuth）
  async initiateSSO(institutionId: string, userId: string): Promise<SSOInitiation> {
    const institution = await institutionRepository.findById(institutionId);
    if (!institution) {
      throw new NotFoundError('Institution not found');
    }
    
    switch (institution.ssoType) {
      case 'SAML':
        return await this.initiateSAMLSSO(institution, userId);
      case 'OAuth':
        return await this.initiateOAuthSSO(institution, userId);
      default:
        throw new ValidationError('Unsupported SSO type');
    }
  }
  
  private async initiateSAMLSSO(institution: Institution, userId: string): Promise<SSOInitiation> {
    const samlRequest = this.ssoProvider.createSAMLRequest({
      issuer: process.env.SAML_ISSUER!,
      destination: institution.samlEndpoint,
      nameIDFormat: 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
      user: await this.getUserSAMLAttributes(userId)
    });
    
    return {
      type: 'SAML',
      redirectUrl: institution.samlEndpoint,
      samlRequest: samlRequest,
      relayState: userId
    };
  }
  
  // 成績同期
  async syncGradesFromInstitution(institutionId: string, courseId: string): Promise<GradeSyncResult> {
    const institution = await institutionRepository.findById(institutionId);
    if (!institution) {
      throw new NotFoundError('Institution not found');
    }
    
    try {
      // 教育機関のAPIから成績データを取得
      const grades = await this.fetchGradesFromInstitution(institution, courseId);
      
      // DX Seedシステムに成績を同期
      const syncResults = await Promise.all(
        grades.map(async (grade) => {
          try {
            await this.updateUserGrade(grade.userId, courseId, grade);
            return { userId: grade.userId, success: true };
          } catch (error) {
            return { userId: grade.userId, success: false, error: error.message };
          }
        })
      );
      
      const successCount = syncResults.filter(r => r.success).length;
      const errorCount = syncResults.filter(r => !r.success).length;
      
      return {
        totalProcessed: grades.length,
        successCount,
        errorCount,
        details: syncResults
      };
    } catch (error: any) {
      throw new AppError('Failed to sync grades', 500, 'GRADE_SYNC_ERROR');
    }
  }
  
  // 出席データ同期
  async syncAttendanceFromInstitution(institutionId: string, courseId: string, dateRange: DateRange): Promise<AttendanceSyncResult> {
    const institution = await institutionRepository.findById(institutionId);
    if (!institution) {
      throw new NotFoundError('Institution not found');
    }
    
    const attendanceData = await this.fetchAttendanceFromInstitution(institution, courseId, dateRange);
    
    const syncResults = await Promise.all(
      attendanceData.map(async (attendance) => {
        try {
          await this.updateUserAttendance(attendance.userId, courseId, attendance);
          return { userId: attendance.userId, date: attendance.date, success: true };
        } catch (error) {
          return { userId: attendance.userId, date: attendance.date, success: false, error: error.message };
        }
      })
    );
    
    return {
      totalProcessed: attendanceData.length,
      successCount: syncResults.filter(r => r.success).length,
      errorCount: syncResults.filter(r => !r.success).length,
      details: syncResults
    };
  }
  
  private async fetchGradesFromInstitution(institution: Institution, courseId: string): Promise<Grade[]> {
    const apiClient = axios.create({
      baseURL: institution.apiEndpoint,
      headers: {
        'Authorization': `Bearer ${institution.apiToken}`,
        'Content-Type': 'application/json'
      }
    });
    
    const response = await apiClient.get(`/courses/${courseId}/grades`);
    return response.data.grades;
  }
  
  private async updateUserGrade(userId: string, courseId: string, gradeData: Grade): Promise<void> {
    await learningProgressRepository.updateGrade(userId, courseId, {
      score: gradeData.score,
      maxScore: gradeData.maxScore,
      gradedAt: gradeData.gradedAt,
      feedback: gradeData.feedback
    });
  }
}
```

---

## **10. 監視・運用設計**

### **10.1 監視システム**

```typescript
// 監視サービス
export class MonitoringService {
  private cloudWatchClient: AWS.CloudWatch;
  private datadogClient: DatadogClient;
  private sentryClient: Sentry;
  
  constructor() {
    this.cloudWatchClient = new AWS.CloudWatch();
    this.datadogClient = new DatadogClient({
      apiKey: process.env.DATADOG_API_KEY!,
      appKey: process.env.DATADOG_APP_KEY!
    });
    
    Sentry.init({
      dsn: process.env.SENTRY_DSN,
      environment: process.env.NODE_ENV,
      tracesSampleRate: 0.1
    });
  }
  
  // カスタムメトリクス送信
  async sendCustomMetric(metricName: string, value: number, unit: string, dimensions?: AWS.CloudWatch.Dimensions): Promise<void> {
    const params: AWS.CloudWatch.PutMetricDataRequest = {
      Namespace: 'DXSeed/Application',
      MetricData: [
        {
          MetricName: metricName,
          Value: value,
          Unit: unit as AWS.CloudWatch.StandardUnit,
          Timestamp: new Date(),
          Dimensions: dimensions
        }
      ]
    };
    
    try {
      await this.cloudWatchClient.putMetricData(params).promise();
    } catch (error) {
      console.error('Failed to send metric to CloudWatch:', error);
    }
  }
  
  // アプリケーションメトリクス
  async recordUserActivity(userId: string, activity: string, metadata?: any): Promise<void> {
    // CloudWatch
    await this.sendCustomMetric('UserActivity', 1, 'Count', [
      { Name: 'Activity', Value: activity },
      { Name: 'UserId', Value: userId }
    ]);
    
    // Datadog
    await this.datadogClient.v1.metricsApi.submitMetrics({
      body: {
        series: [
          {
            metric: 'dx_seed.user_activity',
            points: [[Date.now() / 1000, 1]],
            tags: [`activity:${activity}`, `user_id:${userId}`],
            type: 'count'
          }
        ]
      }
    });
    
    // 詳細ログをMongoDB に保存
    await userActivityRepository.create({
      userId,
      activity,
      metadata,
      timestamp: new Date(),
      ipAddress: metadata?.ipAddress,
      userAgent: metadata?.userAgent
    });
  }
  
  // API パフォーマンス監視
  async recordAPIPerformance(endpoint: string, method: string, responseTime: number, statusCode: number): Promise<void> {
    // レスポンス時間メトリクス
    await this.sendCustomMetric('APIResponseTime', responseTime, 'Milliseconds', [
      { Name: 'Endpoint', Value: endpoint },
      { Name: 'Method', Value: method }
    ]);
    
    // ステータスコード別カウント
    await this.sendCustomMetric('APIRequests', 1, 'Count', [
      { Name: 'Endpoint', Value: endpoint },
      { Name: 'Method', Value: method },
      { Name: 'StatusCode', Value: statusCode.toString() }
    ]);
    
    // エラー率追跡
    if (statusCode >= 400) {
      await this.sendCustomMetric('APIErrors', 1, 'Count', [
        { Name: 'Endpoint', Value: endpoint },
        { Name: 'StatusCode', Value: statusCode.toString() }
      ]);
    }
    
    // Datadog APM
    await this.datadogClient.v1.metricsApi.submitMetrics({
      body: {
        series: [
          {
            metric: 'dx_seed.api.response_time',
            points: [[Date.now() / 1000, responseTime]],
            tags: [`endpoint:${endpoint}`, `method:${method}`, `status:${statusCode}`],
            type: 'gauge'
          }
        ]
      }
    });
  }
  
  // ビジネスメトリクス
  async recordBusinessMetric(metricType: BusinessMetricType, value: number, metadata?: any): Promise<void> {
    const metricName = this.getBusinessMetricName(metricType);
    
    await this.sendCustomMetric(metricName, value, 'Count', [
      { Name: 'MetricType', Value: metricType }
    ]);
    
    // ビジネスKPI追跡
    await businessMetricsRepository.create({
      metricType,
      value,
      metadata,
      timestamp: new Date()
    });
  }
  
  // アラート設定
  async setupAlerts(): Promise<void> {
    const alerts = [
      {
        name: 'HighErrorRate',
        metric: 'APIErrors',
        threshold: 10,
        period: 300, // 5分
        comparison: 'GreaterThanThreshold'
      },
      {
        name: 'HighResponseTime',
        metric: 'APIResponseTime',
        threshold: 5000, // 5秒
        period: 300,
        comparison: 'GreaterThanThreshold'
      },
      {
        name: 'LowUserActivity',
        metric: 'UserActivity',
        threshold: 50,
        period: 3600, // 1時間
        comparison: 'LessThanThreshold'
      }
    ];
    
    for (const alert of alerts) {
      await this.createCloudWatchAlarm(alert);
    }
  }
  
  private async createCloudWatchAlarm(alertConfig: AlertConfig): Promise<void> {
    const params: AWS.CloudWatch.PutMetricAlarmRequest = {
      AlarmName: `DXSeed-${alertConfig.name}`,
      AlarmDescription: `Alert for ${alertConfig.name}`,
      MetricName: alertConfig.metric,
      Namespace: 'DXSeed/Application',
      Statistic: 'Sum',
      Period: alertConfig.period,
      EvaluationPeriods: 1,
      Threshold: alertConfig.threshold,
      ComparisonOperator: alertConfig.comparison as AWS.CloudWatch.ComparisonOperator,
      AlarmActions: [
        process.env.SNS_ALERT_TOPIC_ARN!
      ],
      TreatMissingData: 'notBreaching'
    };
    
    await this.cloudWatchClient.putMetricAlarm(params).promise();
  }
  
  private getBusinessMetricName(metricType: BusinessMetricType): string {
    const metricNames: Record<BusinessMetricType, string> = {
      'user_registration': 'UserRegistrations',
      'course_completion': 'CourseCompletions',
      'matching_success': 'MatchingSuccesses',
      'payment_processed': 'PaymentsProcessed',
      'consultation_completed': 'ConsultationsCompleted'
    };
    
    return metricNames[metricType];
  }
}

// パフォーマンス監視ミドルウェア
export const performanceMonitoring = (monitoringService: MonitoringService) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    
    // レスポンス終了時にメトリクス記録
    res.on('finish', async () => {
      const responseTime = Date.now() - startTime;
      const endpoint = req.route?.path || req.path;
      const method = req.method;
      const statusCode = res.statusCode;
      
      await monitoringService.recordAPIPerformance(endpoint, method, responseTime, statusCode);
      
      // 遅いリクエストをログ出力
      if (responseTime > 5000) {
        logger.warn('Slow request detected', {
          endpoint,
          method,
          responseTime,
          statusCode,
          userAgent: req.get('User-Agent'),
          userId: req.user?.id
        });
      }
    });
    
    next();
  };
};
```

### **10.2 ログ管理**

```typescript
// 構造化ログサービス
export class LoggingService {
  private logger: winston.Logger;
  private elasticsearchClient: Client;
  
  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: {
        service: process.env.SERVICE_NAME || 'dx-seed',
        environment: process.env.NODE_ENV || 'development',
        version: process.env.APP_VERSION || '1.0.0'
      },
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        }),
        new winston.transports.File({
          filename: 'logs/error.log',
          level: 'error',
          maxsize: 5242880, // 5MB
          maxFiles: 5
        }),
        new winston.transports.File({
          filename: 'logs/combined.log',
          maxsize: 5242880,
          maxFiles: 5
        })
      ]
    });
    
    // 本番環境ではElasticsearchにもログを送信
    if (process.env.NODE_ENV === 'production') {
      this.elasticsearchClient = new Client({
        node: process.env.ELASTICSEARCH_URL!,
        auth: {
          username: process.env.ELASTICSEARCH_USERNAME!,
          password: process.env.ELASTICSEARCH_PASSWORD!
        }
      });
      
      this.logger.add(new ElasticsearchTransport({
        client: this.elasticsearchClient,
        index: 'dx-seed-logs'
      }));
    }
  }
  
  // 構造化ログ出力
  logEvent(level: LogLevel, message: string, metadata: LogMetadata): void {
    const logEntry = {
      message,
      level,
      timestamp: new Date().toISOString(),
      ...metadata,
      ...(metadata.userId && { userId: metadata.userId }),
      ...(metadata.requestId && { requestId: metadata.requestId }),
      ...(metadata.correlationId && { correlationId: metadata.correlationId })
    };
    
    this.logger.log(level, logEntry);
  }
  
  // セキュリティログ
  logSecurityEvent(event: SecurityEvent): void {
    const securityLog = {
      eventType: 'SECURITY',
      securityEvent: event.type,
      severity: event.severity,
      userId: event.userId,
      ipAddress: event.ipAddress,
      userAgent: event.userAgent,
      timestamp: new Date().toISOString(),
      details: event.details,
      riskScore: event.riskScore
    };
    
    this.logger.warn('Security event detected', securityLog);
    
    // 高リスクイベントは即座にアラート
    if (event.severity === 'CRITICAL' || event.riskScore > 80) {
      this.sendSecurityAlert(securityLog);
    }
  }
  
  // 監査ログ
  logAuditEvent(event: AuditEvent): void {
    const auditLog = {
      eventType: 'AUDIT',
      action: event.action,
      resource: event.resource,
      userId: event.userId,
      timestamp: new Date().toISOString(),
      before: event.before,
      after: event.after,
      result: event.result,
      ipAddress: event.ipAddress
    };
    
    this.logger.info('Audit event', auditLog);
    
    // 監査ログは別途保存（長期保管用）
    this.saveAuditLog(auditLog);
  }
  
  // パフォーマンスログ
  logPerformanceEvent(event: PerformanceEvent): void {
    const performanceLog = {
      eventType: 'PERFORMANCE',
      operation: event.operation,
      duration: event.duration,
      success: event.success,
      timestamp: new Date().toISOString(),
      metadata: event.metadata
    };
    
    // 閾値を超えた場合は警告
    if (event.duration > event.threshold) {
      this.logger.warn('Performance threshold exceeded', performanceLog);
    } else {
      this.logger.info('Performance event', performanceLog);
    }
  }
  
  // エラー詳細ログ
  logError(error: Error, context?: ErrorContext): void {
    const errorLog = {
      eventType: 'ERROR',
      message: error.message,
      stack: error.stack,
      name: error.name,
      timestamp: new Date().toISOString(),
      ...context
    };
    
    this.logger.error('Application error', errorLog);
    
    // Sentryにもエラー送信
    Sentry.captureException(error, {
      extra: context,
      user: context?.userId ? { id: context.userId } : undefined
    });
  }
  
  private async sendSecurityAlert(securityLog: any): Promise<void> {
    // Slack, メール等でセキュリティアラート送信
    try {
      await axios.post(process.env.SLACK_SECURITY_WEBHOOK!, {
        text: `🚨 Security Alert: ${securityLog.securityEvent}`,
        attachments: [
          {
            color: 'danger',
            fields: [
              { title: 'User ID', value: securityLog.userId, short: true },
              { title: 'IP Address', value: securityLog.ipAddress, short: true },
              { title: 'Risk Score', value: securityLog.riskScore, short: true },
              { title: 'Details', value: JSON.stringify(securityLog.details), short: false }
            ]
          }
        ]
      });
    } catch (error) {
      this.logger.error('Failed to send security alert', { error });
    }
  }
  
  private async saveAuditLog(auditLog: any): Promise<void> {
    // 監査ログは改ざん防止のため、専用の保存領域に
    try {
      await auditLogRepository.create(auditLog);
    } catch (error) {
      this.logger.error('Failed to save audit log', { error, auditLog });
    }
  }
}

// ログ集約・分析サービス
export class LogAnalyticsService {
  private elasticsearchClient: Client;
  private kibanaClient: KibanaClient;
  
  constructor() {
    this.elasticsearchClient = new Client({
      node: process.env.ELASTICSEARCH_URL!
    });
    this.kibanaClient = new KibanaClient({
      baseURL: process.env.KIBANA_URL!
    });
  }
  
  // ログトレンド分析
  async analyzeLogTrends(timeRange: TimeRange): Promise<LogTrendAnalysis> {
    const query = {
      index: 'dx-seed-logs-*',
      body: {
        query: {
          range: {
            timestamp: {
              gte: timeRange.start,
              lte: timeRange.end
            }
          }
        },
        aggs: {
          error_trends: {
            date_histogram: {
              field: 'timestamp',
              calendar_interval: '1h'
            },
            aggs: {
              error_count: {
                filter: {
                  term: { level: 'error' }
                }
              }
            }
          },
          top_errors: {
            terms: {
              field: 'message.keyword',
              size: 10
            }
          },
          user_activity: {
            terms: {
              field: 'userId.keyword',
              size: 100
            }
          }
        }
      }
    };
    
    const response = await this.elasticsearchClient.search(query);
    
    return {
      errorTrends: response.body.aggregations.error_trends.buckets,
      topErrors: response.body.aggregations.top_errors.buckets,
      userActivity: response.body.aggregations.user_activity.buckets,
      totalLogs: response.body.hits.total.value
    };
  }
  
  // アノマリー検出
  async detectAnomalies(metricName: string, timeRange: TimeRange): Promise<Anomaly[]> {
    const query = {
      index: 'dx-seed-logs-*',
      body: {
        query: {
          bool: {
            must: [
              {
                range: {
                  timestamp: {
                    gte: timeRange.start,
                    lte: timeRange.end
                  }
                }
              },
              {
                exists: {
                  field: metricName
                }
              }
            ]
          }
        },
        aggs: {
          metric_over_time: {
            date_histogram: {
              field: 'timestamp',
              calendar_interval: '1m'
            },
            aggs: {
              metric_value: {
                avg: {
                  field: metricName
                }
              }
            }
          }
        }
      }
    };
    
    const response = await this.elasticsearchClient.search(query);
    const buckets = response.body.aggregations.metric_over_time.buckets;
    
    // 簡単な異常検知アルゴリズム（標準偏差ベース）
    const values = buckets.map((bucket: any) => bucket.metric_value.value || 0);
    const mean = values.reduce((sum: number, val: number) => sum + val, 0) / values.length;
    const stdDev = Math.sqrt(
      values.reduce((sum: number, val: number) => sum + Math.pow(val - mean, 2), 0) / values.length
    );
    
    const anomalies: Anomaly[] = [];
    const threshold = 2 * stdDev; // 2σを閾値とする
    
    buckets.forEach((bucket: any, index: number) => {
      const value = bucket.metric_value.value || 0;
      if (Math.abs(value - mean) > threshold) {
        anomalies.push({
          timestamp: bucket.key_as_string,
          value,
          expectedValue: mean,
          deviation: Math.abs(value - mean),
          severity: Math.abs(value - mean) > 3 * stdDev ? 'HIGH' : 'MEDIUM'
        });
      }
    });
    
    return anomalies;
  }
}
```

### **10.3 アラート・通知システム**

```typescript
// アラート管理サービス
export class AlertService {
  private slackClient: WebClient;
  private emailService: EmailService;
  private smsService: SMSService;
  private alertRules: AlertRule[];
  
  constructor() {
    this.slackClient = new WebClient(process.env.SLACK_BOT_TOKEN);
    this.emailService = new EmailService();
    this.smsService = new SMSService();
    this.alertRules = this.loadAlertRules();
  }
  
  // アラート評価・送信
  async evaluateAndSendAlerts(metric: MetricData): Promise<void> {
    const triggeredRules = this.alertRules.filter(rule => 
      this.evaluateRule(rule, metric)
    );
    
    for (const rule of triggeredRules) {
      // アラート頻度制限チェック
      if (await this.isRateLimited(rule.id, metric.timestamp)) {
        continue;
      }
      
      const alert: Alert = {
        id: uuidv4(),
        ruleId: rule.id,
        ruleName: rule.name,
        severity: rule.severity,
        metric: metric,
        threshold: rule.threshold,
        timestamp: metric.timestamp,
        message: this.generateAlertMessage(rule, metric)
      };
      
      await this.sendAlert(alert, rule.channels);
      await this.recordAlert(alert);
    }
  }
  
  private evaluateRule(rule: AlertRule, metric: MetricData): boolean {
    switch (rule.operator) {
      case 'GREATER_THAN':
        return metric.value > rule.threshold;
      case 'LESS_THAN':
        return metric.value < rule.threshold;
      case 'EQUALS':
        return metric.value === rule.threshold;
      case 'NOT_EQUALS':
        return metric.value !== rule.threshold;
      default:
        return false;
    }
  }
  
  private async sendAlert(alert: Alert, channels: AlertChannel[]): Promise<void> {
    const promises = channels.map(channel => {
      switch (channel.type) {
        case 'SLACK':
          return this.sendSlackAlert(alert, channel);
        case 'EMAIL':
          return this.sendEmailAlert(alert, channel);
        case 'SMS':
          return this.sendSMSAlert(alert, channel);
        case 'WEBHOOK':
          return this.sendWebhookAlert(alert, channel);
        default:
          return Promise.resolve();
      }
    });
    
    await Promise.allSettled(promises);
  }
  
  private async sendSlackAlert(alert: Alert, channel: AlertChannel): Promise<void> {
    const color = this.getSeverityColor(alert.severity);
    const emoji = this.getSeverityEmoji(alert.severity);
    
    try {
      await this.slackClient.chat.postMessage({
        channel: channel.destination,
        text: `${emoji} ${alert.ruleName}`,
        attachments: [
          {
            color,
            fields: [
              { title: 'Severity', value: alert.severity, short: true },
              { title: 'Metric', value: alert.metric.name, short: true },
              { title: 'Current Value', value: alert.metric.value.toString(), short: true },
              { title: 'Threshold', value: alert.threshold.toString(), short: true },
              { title: 'Time', value: alert.timestamp.toISOString(), short: true },
              { title: 'Message', value: alert.message, short: false }
            ],
            actions: [
              {
                type: 'button',
                text: 'View Dashboard',
                url: `${process.env.MONITORING_DASHBOARD_URL}/alerts/${alert.id}`
              },
              {
                type: 'button',
                text: 'Acknowledge',
                name: 'acknowledge',
                value: alert.id
              }
            ]
          }
        ]
      });
    } catch (error) {
      logger.error('Failed to send Slack alert', { error, alertId: alert.id });
    }
  }
  
  private async sendEmailAlert(alert: Alert, channel: AlertChannel): Promise<void> {
    const template = this.getEmailTemplate(alert.severity);
    
    try {
      await this.emailService.sendEmail({
        to: channel.destination,
        subject: `[${alert.severity}] ${alert.ruleName}`,
        template,
        templateData: {
          alert,
          dashboardUrl: `${process.env.MONITORING_DASHBOARD_URL}/alerts/${alert.id}`
        }
      });
    } catch (error) {
      logger.error('Failed to send email alert', { error, alertId: alert.id });
    }
  }
  
  // アラート状態管理
  async acknowledgeAlert(alertId: string, acknowledgedBy: string): Promise<void> {
    await alertRepository.update(alertId, {
      status: 'ACKNOWLEDGED',
      acknowledgedBy,
      acknowledgedAt: new Date()
    });
    
    // Slack通知更新
    await this.updateSlackMessage(alertId, 'ACKNOWLEDGED');
  }
  
  async resolveAlert(alertId: string, resolvedBy: string, resolution: string): Promise<void> {
    await alertRepository.update(alertId, {
      status: 'RESOLVED',
      resolvedBy,
      resolvedAt: new Date(),
      resolution
    });
    
    // Slack通知更新
    await this.updateSlackMessage(alertId, 'RESOLVED');
  }
  
  // エスカレーション管理
  async checkEscalation(): Promise<void> {
    const unacknowledgedAlerts = await alertRepository.findUnacknowledged();
    
    for (const alert of unacknowledgedAlerts) {
      const timeSinceCreated = Date.now() - alert.timestamp.getTime();
      const escalationRule = this.getEscalationRule(alert.severity);
      
      if (timeSinceCreated > escalationRule.timeThreshold) {
        await this.escalateAlert(alert, escalationRule);
      }
    }
  }
  
  private async escalateAlert(alert: Alert, escalationRule: EscalationRule): Promise<void> {
    // より上位の担当者にアラートを送信
    const escalationChannels = escalationRule.channels;
    
    const escalatedAlert = {
      ...alert,
      id: uuidv4(),
      severity: this.increaseSeverity(alert.severity),
      message: `[ESCALATED] ${alert.message}`,
      escalatedFrom: alert.id
    };
    
    await this.sendAlert(escalatedAlert, escalationChannels);
    await this.recordAlert(escalatedAlert);
    
    // 元のアラートを更新
    await alertRepository.update(alert.id, {
      escalated: true,
      escalatedAt: new Date(),
      escalatedTo: escalatedAlert.id
    });
  }
  
  private async isRateLimited(ruleId: string, timestamp: Date): Promise<boolean> {
    const key = `alert_rate_limit:${ruleId}`;
    const windowStart = new Date(timestamp.getTime() - 5 * 60 * 1000); // 5分間
    
    const recentAlerts = await alertRepository.countByRuleAndTimeRange(ruleId, windowStart, timestamp);
    
    return recentAlerts >= 3; // 5分間で3回まで
  }
  
  private getSeverityColor(severity: AlertSeverity): string {
    const colors = {
      'LOW': 'good',
      'MEDIUM': 'warning',
      'HIGH': 'danger',
      'CRITICAL': '#ff0000'
    };
    return colors[severity];
  }
  
  private getSeverityEmoji(severity: AlertSeverity): string {
    const emojis = {
      'LOW': '💙',
      'MEDIUM': '💛',
      'HIGH': '🧡',
      'CRITICAL': '🔴'
    };
    return emojis[severity];
  }
}

// ヘルスチェック
export class HealthCheckService {
  private dependencies: HealthCheckDependency[];
  
  constructor() {
    this.dependencies = [
      { name: 'PostgreSQL', check: () => this.checkPostgreSQL() },
      { name: 'Redis', check: () => this.checkRedis() },
      { name: 'Elasticsearch', check: () => this.checkElasticsearch() },
      { name: 'External APIs', check: () => this.checkExternalAPIs() }
    ];
  }
  
  async performHealthCheck(): Promise<HealthCheckResult> {
    const startTime = Date.now();
    const results = await Promise.allSettled(
      this.dependencies.map(async (dep) => {
        const depStartTime = Date.now();
        try {
          await dep.check();
          return {
            name: dep.name,
            status: 'UP',
            responseTime: Date.now() - depStartTime
          };
        } catch (error) {
          return {
            name: dep.name,
            status: 'DOWN',
            responseTime: Date.now() - depStartTime,
            error: error.message
          };
        }
      })
    );
    
    const dependencyResults = results.map((result, index) => 
      result.status === 'fulfilled' ? result.value : {
        name: this.dependencies[index].name,
        status: 'DOWN',
        error: 'Health check failed'
      }
    );
    
    const allHealthy = dependencyResults.every(result => result.status === 'UP');
    
    return {
      status: allHealthy ? 'UP' : 'DOWN',
      timestamp: new Date().toISOString(),
      responseTime: Date.now() - startTime,
      dependencies: dependencyResults,
      version: process.env.APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development'
    };
  }
  
  private async checkPostgreSQL(): Promise<void> {
    await sequelize.authenticate();
  }
  
  private async checkRedis(): Promise<void> {
    await redisClient.ping();
  }
  
  private async checkElasticsearch(): Promise<void> {
    await elasticsearchClient.ping();
  }
  
  private async checkExternalAPIs(): Promise<void> {
    // 主要な外部APIの疎通確認
    const checks = [
      axios.get('https://api.openai.com/v1/models', { timeout: 5000 }),
      axios.get('https://api.stripe.com/v1/payment_methods', { timeout: 5000 })
    ];
    
    await Promise.all(checks);
  }
}
```
